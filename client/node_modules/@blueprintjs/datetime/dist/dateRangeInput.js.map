{"version":3,"sources":["../src/dateRangeInput.tsx"],"names":[],"mappings":"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","file":"dateRangeInput.js","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport * as classNames from \"classnames\";\nimport * as moment from \"moment\";\nimport * as React from \"react\";\nimport * as ReactDayPicker from \"react-day-picker\";\n\nimport {\n    AbstractComponent,\n    Classes,\n    HTMLInputProps,\n    IInputGroupProps,\n    InputGroup,\n    IPopoverProps,\n    IProps,\n    Keys,\n    Popover,\n    Position,\n    Utils,\n} from \"@blueprintjs/core\";\n\nimport {\n    DateRange,\n    DateRangeBoundary,\n    fromDateRangeToMomentDateRange,\n    fromDateToMoment,\n    fromMomentToDate,\n    isMomentInRange,\n    isMomentNull,\n    isMomentValidAndInRange,\n    MomentDateRange,\n    toLocalizedDateString,\n} from \"./common/dateUtils\";\nimport * as Errors from \"./common/errors\";\nimport { getDefaultMaxDate, getDefaultMinDate, IDatePickerBaseProps } from \"./datePickerCore\";\nimport { DateRangePicker, IDateRangeShortcut } from \"./dateRangePicker\";\n\nexport interface IDateRangeInputProps extends IDatePickerBaseProps, IProps {\n    /**\n     * Whether the start and end dates of the range can be the same day.\n     * If `true`, clicking a selected date will create a one-day range.\n     * If `false`, clicking a selected date will clear the selection.\n     * @default false\n     */\n    allowSingleDayRange?: boolean;\n\n    /**\n     * Whether the calendar popover should close when a date range is fully selected.\n     * @default true\n     */\n    closeOnSelection?: boolean;\n\n    /**\n     * Whether displayed months in the calendar are contiguous.\n     * If false, each side of the calendar can move independently to non-contiguous months.\n     * @default true\n     */\n    contiguousCalendarMonths?: boolean;\n\n    /**\n     * Props to pass to ReactDayPicker. See API documentation\n     * [here](http://react-day-picker.js.org/docs/api-daypicker.html).\n     *\n     * The following props are managed by the component and cannot be configured:\n     * `canChangeMonth`, `captionElement`, `numberOfMonths`, `fromMonth` (use\n     * `minDate`), `month` (use `initialMonth`), `toMonth` (use `maxDate`).\n     */\n    dayPickerProps?: ReactDayPicker.Props;\n\n    /**\n     * The default date range to be used in the component when uncontrolled.\n     * This will be ignored if `value` is set.\n     */\n    defaultValue?: DateRange;\n\n    /**\n     * Whether the text inputs are non-interactive.\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Props to pass to the end-date [input group](#core/components/forms/input-group.javascript-api).\n     * `disabled` and `value` will be ignored in favor of the top-level props on this component.\n     * `ref` is not supported; use `inputRef` instead.\n     */\n    endInputProps?: HTMLInputProps & IInputGroupProps;\n\n    /**\n     * The format of each date in the date range. See options\n     * here: http://momentjs.com/docs/#/displaying/format/\n     * @default \"YYYY-MM-DD\"\n     */\n    format?: string;\n\n    /**\n     * The error message to display when the selected date is invalid.\n     * @default \"Invalid date\"\n     */\n    invalidDateMessage?: string;\n\n    /**\n     * Called when the user selects a day.\n     * If no days are selected, it will pass `[null, null]`.\n     * If a start date is selected but not an end date, it will pass `[selectedDate, null]`.\n     * If both a start and end date are selected, it will pass `[startDate, endDate]`.\n     */\n    onChange?: (selectedRange: DateRange) => void;\n\n    /**\n     * Called when the user finishes typing in a new date and the date causes an error state.\n     * If the date is invalid, `new Date(undefined)` will be returned for the corresponding\n     * boundary of the date range.\n     * If the date is out of range, the out-of-range date will be returned for the corresponding\n     * boundary of the date range (`onChange` is not called in this case).\n     */\n    onError?: (errorRange: DateRange) => void;\n\n    /**\n     * The error message to display when the date selected is out of range.\n     * @default \"Out of range\"\n     */\n    outOfRangeMessage?: string;\n\n    /**\n     * The error message to display when the selected dates overlap.\n     * This can only happen when typing dates in the input field.\n     * @default \"Overlapping dates\"\n     */\n    overlappingDatesMessage?: string;\n\n    /**\n     * The props to pass to the popover.\n     * `autoFocus`, `content`, and `enforceFocus` will be ignored to avoid compromising usability.\n     */\n    popoverProps?: Partial<IPopoverProps>;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * Whether shortcuts to quickly select a range of dates are displayed or not.\n     * If `true`, preset shortcuts will be displayed.\n     * If `false`, no shortcuts will be displayed.\n     * If an array is provided, the custom shortcuts will be displayed.\n     * @default true\n     */\n    shortcuts?: boolean | IDateRangeShortcut[];\n\n    /**\n     * Props to pass to the start-date [input group](#core/components/forms/input-group.javascript-api).\n     * `disabled` and `value` will be ignored in favor of the top-level props on this component.\n     * `ref` is not supported; use `inputRef` instead.\n     */\n    startInputProps?: HTMLInputProps & IInputGroupProps;\n\n    /**\n     * The currently selected date range.\n     * If the prop is strictly `undefined`, the component acts in an uncontrolled manner.\n     * If this prop is anything else, the component acts in a controlled manner.\n     * To display an empty value in the input fields in a controlled manner, pass `[null, null]`.\n     * To display an invalid date error in either input field, pass `new Date(undefined)`\n     * for the appropriate date in the value prop.\n     */\n    value?: DateRange;\n}\n\nexport interface IDateRangeInputState {\n    isOpen?: boolean;\n    boundaryToModify?: DateRangeBoundary;\n    lastFocusedField?: DateRangeBoundary;\n\n    formattedMinDateString?: string;\n    formattedMaxDateString?: string;\n\n    isStartInputFocused?: boolean;\n    isEndInputFocused?: boolean;\n\n    startInputString?: string;\n    endInputString?: string;\n\n    startHoverString?: string;\n    endHoverString?: string;\n\n    selectedEnd?: moment.Moment;\n    selectedStart?: moment.Moment;\n\n    shouldSelectAfterUpdate?: boolean;\n    wasLastFocusChangeDueToHover?: boolean;\n}\n\ninterface IStateKeysAndValuesObject {\n    keys: {\n        hoverString: \"startHoverString\" | \"endHoverString\";\n        inputString: \"startInputString\" | \"endInputString\";\n        isInputFocused: \"isStartInputFocused\" | \"isEndInputFocused\";\n        selectedValue: \"selectedStart\" | \"selectedEnd\";\n    };\n    values: {\n        controlledValue?: moment.Moment;\n        hoverString?: string;\n        inputString?: string;\n        isInputFocused?: boolean;\n        selectedValue?: moment.Moment;\n    };\n}\n\nexport class DateRangeInput extends AbstractComponent<IDateRangeInputProps, IDateRangeInputState> {\n    public static defaultProps: IDateRangeInputProps = {\n        allowSingleDayRange: false,\n        closeOnSelection: true,\n        contiguousCalendarMonths: true,\n        dayPickerProps: {},\n        disabled: false,\n        endInputProps: {},\n        format: \"YYYY-MM-DD\",\n        invalidDateMessage: \"Invalid date\",\n        maxDate: getDefaultMaxDate(),\n        minDate: getDefaultMinDate(),\n        outOfRangeMessage: \"Out of range\",\n        overlappingDatesMessage: \"Overlapping dates\",\n        popoverProps: {},\n        selectAllOnFocus: false,\n        shortcuts: true,\n        startInputProps: {},\n    };\n\n    public static displayName = \"Blueprint.DateRangeInput\";\n\n    private startInputRef: HTMLInputElement;\n    private endInputRef: HTMLInputElement;\n    private refHandlers = {\n        endInputRef: (ref: HTMLInputElement) => {\n            this.endInputRef = ref;\n            Utils.safeInvoke(this.props.endInputProps.inputRef, ref);\n        },\n        startInputRef: (ref: HTMLInputElement) => {\n            this.startInputRef = ref;\n            Utils.safeInvoke(this.props.startInputProps.inputRef, ref);\n        },\n    };\n\n    public constructor(props: IDateRangeInputProps, context?: any) {\n        super(props, context);\n        this.reset(props);\n    }\n\n    /**\n     * Public method intended for unit testing only. Do not use in feature work!\n     */\n    public reset(props: IDateRangeInputProps = this.props) {\n        const [selectedStart, selectedEnd] = this.getInitialRange();\n        this.state = {\n            formattedMaxDateString: this.getFormattedMinMaxDateString(props, \"maxDate\"),\n            formattedMinDateString: this.getFormattedMinMaxDateString(props, \"minDate\"),\n            isOpen: false,\n            selectedEnd,\n            selectedStart,\n        };\n    }\n\n    public componentDidUpdate() {\n        const { isStartInputFocused, isEndInputFocused, shouldSelectAfterUpdate } = this.state;\n\n        const shouldFocusStartInput = this.shouldFocusInputRef(isStartInputFocused, this.startInputRef);\n        const shouldFocusEndInput = this.shouldFocusInputRef(isEndInputFocused, this.endInputRef);\n\n        if (shouldFocusStartInput) {\n            this.startInputRef.focus();\n        } else if (shouldFocusEndInput) {\n            this.endInputRef.focus();\n        }\n\n        if (isStartInputFocused && shouldSelectAfterUpdate) {\n            this.startInputRef.select();\n        } else if (isEndInputFocused && shouldSelectAfterUpdate) {\n            this.endInputRef.select();\n        }\n    }\n\n    public render() {\n        const popoverContent = (\n            <DateRangePicker\n                {...this.props}\n                boundaryToModify={this.state.boundaryToModify}\n                onChange={this.handleDateRangePickerChange}\n                onHoverChange={this.handleDateRangePickerHoverChange}\n                value={this.getSelectedRange()}\n            />\n        );\n\n        // allow custom props for the popover and each input group, but pass them in an order that\n        // guarantees only some props are overridable.\n        return (\n            <Popover\n                inline={true}\n                isOpen={this.state.isOpen}\n                position={Position.BOTTOM_LEFT}\n                {...this.props.popoverProps}\n                autoFocus={false}\n                content={popoverContent}\n                enforceFocus={false}\n                onClose={this.handlePopoverClose}\n            >\n                <div className={Classes.CONTROL_GROUP}>\n                    {this.renderInputGroup(DateRangeBoundary.START)}\n                    {this.renderInputGroup(DateRangeBoundary.END)}\n                </div>\n            </Popover>\n        );\n    }\n\n    public componentWillReceiveProps(nextProps: IDateRangeInputProps) {\n        super.componentWillReceiveProps(nextProps);\n\n        let nextState: IDateRangeInputState = {};\n\n        if (nextProps.value !== this.props.value) {\n            const [selectedStart, selectedEnd] = this.getInitialRange(nextProps);\n            nextState = { ...nextState, selectedStart, selectedEnd };\n        }\n\n        // we use Moment to format date strings, but min/max dates come in as vanilla JS Dates.\n        // cache the formatted date strings to avoid creating new Moment instances on each render.\n        const didFormatChange = nextProps.format !== this.props.format;\n        if (didFormatChange || nextProps.minDate !== this.props.minDate) {\n            const formattedMinDateString = this.getFormattedMinMaxDateString(nextProps, \"minDate\");\n            nextState = { ...nextState, formattedMinDateString };\n        }\n        if (didFormatChange || nextProps.maxDate !== this.props.maxDate) {\n            const formattedMaxDateString = this.getFormattedMinMaxDateString(nextProps, \"maxDate\");\n            nextState = { ...nextState, formattedMaxDateString };\n        }\n\n        this.setState(nextState);\n    }\n\n    protected validateProps(props: IDateRangeInputProps) {\n        if (props.value === null) {\n            throw new Error(Errors.DATERANGEINPUT_NULL_VALUE);\n        }\n    }\n\n    private renderInputGroup = (boundary: DateRangeBoundary) => {\n        const inputProps = this.getInputProps(boundary);\n\n        // don't include `ref` in the returned HTML props, because passing it to the InputGroup\n        // leads to TS typing errors.\n        const { ref, ...htmlProps } = inputProps;\n\n        const handleInputEvent =\n            boundary === DateRangeBoundary.START ? this.handleStartInputEvent : this.handleEndInputEvent;\n\n        const classes = classNames(\n            {\n                [Classes.INTENT_DANGER]: this.isInputInErrorState(boundary),\n            },\n            inputProps.className,\n        );\n\n        return (\n            <InputGroup\n                autoComplete=\"off\"\n                {...htmlProps}\n                className={classes}\n                disabled={this.props.disabled}\n                inputRef={this.getInputRef(boundary)}\n                onBlur={handleInputEvent}\n                onChange={handleInputEvent}\n                onClick={handleInputEvent}\n                onFocus={handleInputEvent}\n                onKeyDown={handleInputEvent}\n                onMouseDown={handleInputEvent}\n                placeholder={this.getInputPlaceholderString(boundary)}\n                value={this.getInputDisplayString(boundary)}\n            />\n        );\n    };\n\n    // Callbacks - DateRangePicker\n    // ===========================\n\n    private handleDateRangePickerChange = (selectedRange: DateRange) => {\n        // ignore mouse events in the date-range picker if the popover is animating closed.\n        if (!this.state.isOpen) {\n            return;\n        }\n\n        const [selectedStart, selectedEnd] = fromDateRangeToMomentDateRange(selectedRange);\n\n        let isOpen = true;\n\n        let isStartInputFocused: boolean;\n        let isEndInputFocused: boolean;\n\n        let startHoverString: string;\n        let endHoverString: string;\n\n        if (isMomentNull(selectedStart)) {\n            // focus the start field by default or if only an end date is specified\n            isStartInputFocused = true;\n            isEndInputFocused = false;\n\n            // for clarity, hide the hover string until the mouse moves over a different date\n            startHoverString = null;\n        } else if (isMomentNull(selectedEnd)) {\n            // focus the end field if a start date is specified\n            isStartInputFocused = false;\n            isEndInputFocused = true;\n\n            endHoverString = null;\n        } else if (this.props.closeOnSelection) {\n            isOpen = false;\n            isStartInputFocused = false;\n            isEndInputFocused = false;\n        } else if (this.state.lastFocusedField === DateRangeBoundary.START) {\n            // keep the start field focused\n            isStartInputFocused = true;\n            isEndInputFocused = false;\n        } else {\n            // keep the end field focused\n            isStartInputFocused = false;\n            isEndInputFocused = true;\n        }\n\n        const baseStateChange = {\n            endHoverString,\n            endInputString: this.getFormattedDateString(selectedEnd),\n            isEndInputFocused,\n            isOpen,\n            isStartInputFocused,\n            startHoverString,\n            startInputString: this.getFormattedDateString(selectedStart),\n            wasLastFocusChangeDueToHover: false,\n        };\n\n        if (this.isControlled()) {\n            this.setState(baseStateChange);\n        } else {\n            this.setState({ ...baseStateChange, selectedEnd, selectedStart });\n        }\n\n        Utils.safeInvoke(this.props.onChange, selectedRange);\n    };\n\n    private handleDateRangePickerHoverChange = (\n        hoveredRange: DateRange,\n        _hoveredDay: Date,\n        hoveredBoundary: DateRangeBoundary,\n    ) => {\n        // ignore mouse events in the date-range picker if the popover is animating closed.\n        if (!this.state.isOpen) {\n            return;\n        }\n\n        if (hoveredRange == null) {\n            // undo whatever focus changes we made while hovering over various calendar dates\n            const isEndInputFocused = this.state.boundaryToModify === DateRangeBoundary.END;\n\n            this.setState({\n                endHoverString: null,\n                isEndInputFocused,\n                isStartInputFocused: !isEndInputFocused,\n                lastFocusedField: this.state.boundaryToModify,\n                startHoverString: null,\n            });\n        } else {\n            const [hoveredStart, hoveredEnd] = fromDateRangeToMomentDateRange(hoveredRange);\n            const isStartInputFocused =\n                hoveredBoundary != null ? hoveredBoundary === DateRangeBoundary.START : this.state.isStartInputFocused;\n            const isEndInputFocused =\n                hoveredBoundary != null ? hoveredBoundary === DateRangeBoundary.END : this.state.isEndInputFocused;\n\n            this.setState({\n                endHoverString: this.getFormattedDateString(hoveredEnd),\n                isEndInputFocused,\n                isStartInputFocused,\n                lastFocusedField: isStartInputFocused ? DateRangeBoundary.START : DateRangeBoundary.END,\n                shouldSelectAfterUpdate: this.props.selectAllOnFocus,\n                startHoverString: this.getFormattedDateString(hoveredStart),\n                wasLastFocusChangeDueToHover: true,\n            });\n        }\n    };\n\n    // Callbacks - Input\n    // =================\n\n    // instantiate these two functions once so we don't have to for each callback on each render.\n\n    private handleStartInputEvent = (e: React.SyntheticEvent<HTMLInputElement>) => {\n        this.handleInputEvent(e, DateRangeBoundary.START);\n    };\n\n    private handleEndInputEvent = (e: React.SyntheticEvent<HTMLInputElement>) => {\n        this.handleInputEvent(e, DateRangeBoundary.END);\n    };\n\n    private handleInputEvent = (e: React.SyntheticEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        switch (e.type) {\n            case \"blur\":\n                this.handleInputBlur(e, boundary);\n                break;\n            case \"change\":\n                this.handleInputChange(e, boundary);\n                break;\n            case \"click\":\n                this.handleInputClick(e as React.MouseEvent<HTMLInputElement>);\n                break;\n            case \"focus\":\n                this.handleInputFocus(e, boundary);\n                break;\n            case \"keydown\":\n                this.handleInputKeyDown(e as React.KeyboardEvent<HTMLInputElement>);\n                break;\n            case \"mousedown\":\n                this.handleInputMouseDown();\n                break;\n            default:\n                break;\n        }\n\n        const inputProps = this.getInputProps(boundary);\n        const callbackFn = this.getInputGroupCallbackForEvent(e, inputProps);\n\n        Utils.safeInvoke(callbackFn, e);\n    };\n\n    // add a keydown listener to persistently change focus when tabbing:\n    // - if focused in start field, Tab moves focus to end field\n    // - if focused in end field, Shift+Tab moves focus to start field\n    private handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        const isTabPressed = e.keyCode === Keys.TAB;\n        const isShiftPressed = e.shiftKey;\n\n        // order of JS events is our enemy here. when tabbing between fields,\n        // this handler will fire in the middle of a focus exchange when no\n        // field is currently focused. we work around this by referring to the\n        // most recently focused field, rather than the currently focused field.\n        const wasStartFieldFocused = this.state.lastFocusedField === DateRangeBoundary.START;\n        const wasEndFieldFocused = this.state.lastFocusedField === DateRangeBoundary.END;\n\n        let isEndInputFocused: boolean;\n        let isStartInputFocused: boolean;\n\n        // move focus to the other field\n        if (wasStartFieldFocused && isTabPressed && !isShiftPressed) {\n            isStartInputFocused = false;\n            isEndInputFocused = true;\n        } else if (wasEndFieldFocused && isTabPressed && isShiftPressed) {\n            isStartInputFocused = true;\n            isEndInputFocused = false;\n        } else {\n            // let the default keystroke happen without side effects\n            return;\n        }\n\n        // prevent the default focus-change behavior to avoid race conditions;\n        // we'll handle the focus change ourselves in componentDidUpdate.\n        e.preventDefault();\n\n        this.setState({\n            isEndInputFocused,\n            isStartInputFocused,\n            wasLastFocusChangeDueToHover: false,\n        });\n    };\n\n    private handleInputMouseDown = () => {\n        // clicking in the field constitutes an explicit focus change. we update\n        // the flag on \"mousedown\" instead of on \"click\", because it needs to be\n        // set before onFocus is called (\"click\" triggers after \"focus\").\n        this.setState({ wasLastFocusChangeDueToHover: false });\n    };\n\n    private handleInputClick = (e: React.MouseEvent<HTMLInputElement>) => {\n        // unless we stop propagation on this event, a click within an input\n        // will close the popover almost as soon as it opens.\n        e.stopPropagation();\n    };\n\n    private handleInputFocus = (_e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const { keys, values } = this.getStateKeysAndValuesForBoundary(boundary);\n        const inputString = this.getFormattedDateString(values.selectedValue);\n\n        // change the boundary only if the user explicitly focused in the field.\n        // focus changes from hovering don't count; they're just temporary.\n        const boundaryToModify = this.state.wasLastFocusChangeDueToHover ? this.state.boundaryToModify : boundary;\n\n        this.setState({\n            [keys.inputString]: inputString,\n            [keys.isInputFocused]: true,\n            boundaryToModify,\n            isOpen: true,\n            lastFocusedField: boundary,\n            shouldSelectAfterUpdate: this.props.selectAllOnFocus,\n            wasLastFocusChangeDueToHover: false,\n        });\n    };\n\n    private handleInputBlur = (_e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const { keys, values } = this.getStateKeysAndValuesForBoundary(boundary);\n\n        const maybeNextValue = this.dateStringToMoment(values.inputString);\n        const isValueControlled = this.isControlled();\n\n        let nextState: IDateRangeInputState = {\n            [keys.isInputFocused]: false,\n            shouldSelectAfterUpdate: false,\n        };\n\n        if (this.isInputEmpty(values.inputString)) {\n            if (isValueControlled) {\n                nextState = {\n                    ...nextState,\n                    [keys.inputString]: this.getFormattedDateString(values.controlledValue),\n                };\n            } else {\n                nextState = {\n                    ...nextState,\n                    [keys.inputString]: null,\n                    [keys.selectedValue]: moment(null),\n                };\n            }\n        } else if (!this.isNextDateRangeValid(maybeNextValue, boundary)) {\n            if (!isValueControlled) {\n                nextState = {\n                    ...nextState,\n                    [keys.inputString]: null,\n                    [keys.selectedValue]: maybeNextValue,\n                };\n            }\n            Utils.safeInvoke(this.props.onError, this.getDateRangeForCallback(maybeNextValue, boundary));\n        }\n\n        this.setState(nextState);\n    };\n\n    private handleInputChange = (e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const inputString = (e.target as HTMLInputElement).value;\n\n        const { keys } = this.getStateKeysAndValuesForBoundary(boundary);\n        const maybeNextValue = this.dateStringToMoment(inputString);\n        const isValueControlled = this.isControlled();\n\n        let nextState: IDateRangeInputState = { shouldSelectAfterUpdate: false };\n\n        if (inputString.length === 0) {\n            // this case will be relevant when we start showing the hovered range in the input\n            // fields. goal is to show an empty field for clarity until the mouse moves over a\n            // different date.\n            const baseState = { ...nextState, [keys.inputString]: \"\" };\n            if (isValueControlled) {\n                nextState = baseState;\n            } else {\n                nextState = { ...baseState, [keys.selectedValue]: moment(null) };\n            }\n            Utils.safeInvoke(this.props.onChange, this.getDateRangeForCallback(moment(null), boundary));\n        } else if (this.isMomentValidAndInRange(maybeNextValue)) {\n            // note that error cases that depend on both fields (e.g. overlapping dates) should fall\n            // through into this block so that the UI can update immediately, possibly with an error\n            // message on the other field.\n            // also, clear the hover string to ensure the most recent keystroke appears.\n            const baseState: IDateRangeInputState = {\n                ...nextState,\n                [keys.hoverString]: null,\n                [keys.inputString]: inputString,\n            };\n            if (isValueControlled) {\n                nextState = baseState;\n            } else {\n                nextState = { ...baseState, [keys.selectedValue]: maybeNextValue };\n            }\n            if (this.isNextDateRangeValid(maybeNextValue, boundary)) {\n                Utils.safeInvoke(this.props.onChange, this.getDateRangeForCallback(maybeNextValue, boundary));\n            }\n        } else {\n            // again, clear the hover string to ensure the most recent keystroke appears\n            nextState = { ...nextState, [keys.inputString]: inputString, [keys.hoverString]: null };\n        }\n\n        this.setState(nextState);\n    };\n\n    // Callbacks - Popover\n    // ===================\n\n    private handlePopoverClose = () => {\n        this.setState({ isOpen: false });\n        Utils.safeInvoke(this.props.popoverProps.onClose);\n    };\n\n    // Helpers\n    // =======\n\n    private shouldFocusInputRef(isFocused: boolean, inputRef: HTMLInputElement) {\n        return isFocused && inputRef !== undefined && document.activeElement !== inputRef;\n    }\n\n    private dateStringToMoment = (dateString: string) => {\n        if (this.isInputEmpty(dateString)) {\n            return moment(null);\n        }\n        return moment(dateString, this.props.format, this.props.locale);\n    };\n\n    private getInitialRange = (props = this.props) => {\n        const { defaultValue, value } = props;\n        if (value != null) {\n            return fromDateRangeToMomentDateRange(value);\n        } else if (defaultValue != null) {\n            return fromDateRangeToMomentDateRange(defaultValue);\n        } else {\n            return [moment(null), moment(null)] as MomentDateRange;\n        }\n    };\n\n    private getSelectedRange = () => {\n        let selectedStart: moment.Moment;\n        let selectedEnd: moment.Moment;\n\n        if (this.isControlled()) {\n            [selectedStart, selectedEnd] = this.props.value.map(fromDateToMoment);\n        } else {\n            selectedStart = this.state.selectedStart;\n            selectedEnd = this.state.selectedEnd;\n        }\n\n        // this helper function checks if the provided boundary date *would* overlap the selected\n        // other boundary date. providing the already-selected start date simply tells us if we're\n        // currently in an overlapping state.\n        const doBoundaryDatesOverlap = this.doBoundaryDatesOverlap(selectedStart, DateRangeBoundary.START);\n        const momentDateRange = [selectedStart, doBoundaryDatesOverlap ? moment(null) : selectedEnd];\n\n        return momentDateRange.map((selectedBound?: moment.Moment) => {\n            return this.isMomentValidAndInRange(selectedBound) ? fromMomentToDate(selectedBound) : undefined;\n        }) as DateRange;\n    };\n\n    private getInputGroupCallbackForEvent = (\n        e: React.SyntheticEvent<HTMLInputElement>,\n        inputProps: HTMLInputProps & IInputGroupProps,\n    ) => {\n        // use explicit switch cases to ensure callback function names remain grep-able in the codebase.\n        switch (e.type) {\n            case \"blur\":\n                return inputProps.onBlur;\n            case \"change\":\n                return inputProps.onChange;\n            case \"click\":\n                return inputProps.onClick;\n            case \"focus\":\n                return inputProps.onFocus;\n            case \"keydown\":\n                return inputProps.onKeyDown;\n            case \"mousedown\":\n                return inputProps.onMouseDown;\n            default:\n                return undefined;\n        }\n    };\n\n    private getInputDisplayString = (boundary: DateRangeBoundary) => {\n        const { values } = this.getStateKeysAndValuesForBoundary(boundary);\n        const { isInputFocused, inputString, selectedValue, hoverString } = values;\n\n        if (hoverString != null) {\n            return hoverString;\n        } else if (isInputFocused) {\n            return inputString == null ? \"\" : inputString;\n        } else if (isMomentNull(selectedValue)) {\n            return \"\";\n        } else if (!this.isMomentInRange(selectedValue)) {\n            return this.props.outOfRangeMessage;\n        } else if (this.doesEndBoundaryOverlapStartBoundary(selectedValue, boundary)) {\n            return this.props.overlappingDatesMessage;\n        } else {\n            return this.getFormattedDateString(selectedValue);\n        }\n    };\n\n    private getInputPlaceholderString = (boundary: DateRangeBoundary) => {\n        const isStartBoundary = boundary === DateRangeBoundary.START;\n        const isEndBoundary = boundary === DateRangeBoundary.END;\n\n        const inputProps = this.getInputProps(boundary);\n        const { isInputFocused } = this.getStateKeysAndValuesForBoundary(boundary).values;\n\n        // use the custom placeholder text for the input, if providied\n        if (inputProps.placeholder != null) {\n            return inputProps.placeholder;\n        } else if (isStartBoundary) {\n            return isInputFocused ? this.state.formattedMinDateString : \"Start date\";\n        } else if (isEndBoundary) {\n            return isInputFocused ? this.state.formattedMaxDateString : \"End date\";\n        } else {\n            return \"\";\n        }\n    };\n\n    private getInputProps = (boundary: DateRangeBoundary) => {\n        return boundary === DateRangeBoundary.START ? this.props.startInputProps : this.props.endInputProps;\n    };\n\n    private getInputRef = (boundary: DateRangeBoundary) => {\n        return boundary === DateRangeBoundary.START ? this.refHandlers.startInputRef : this.refHandlers.endInputRef;\n    };\n\n    private getFormattedDateString = (momentDate: moment.Moment, formatOverride?: string) => {\n        if (isMomentNull(momentDate)) {\n            return \"\";\n        } else if (!momentDate.isValid()) {\n            return this.props.invalidDateMessage;\n        } else {\n            const format = formatOverride != null ? formatOverride : this.props.format;\n            return toLocalizedDateString(momentDate, format, this.props.locale);\n        }\n    };\n\n    private getStateKeysAndValuesForBoundary = (boundary: DateRangeBoundary): IStateKeysAndValuesObject => {\n        const controlledRange = fromDateRangeToMomentDateRange(this.props.value);\n        if (boundary === DateRangeBoundary.START) {\n            return {\n                keys: {\n                    hoverString: \"startHoverString\",\n                    inputString: \"startInputString\",\n                    isInputFocused: \"isStartInputFocused\",\n                    selectedValue: \"selectedStart\",\n                },\n                values: {\n                    controlledValue: controlledRange != null ? controlledRange[0] : undefined,\n                    hoverString: this.state.startHoverString,\n                    inputString: this.state.startInputString,\n                    isInputFocused: this.state.isStartInputFocused,\n                    selectedValue: this.state.selectedStart,\n                },\n            };\n        } else {\n            return {\n                keys: {\n                    hoverString: \"endHoverString\",\n                    inputString: \"endInputString\",\n                    isInputFocused: \"isEndInputFocused\",\n                    selectedValue: \"selectedEnd\",\n                },\n                values: {\n                    controlledValue: controlledRange != null ? controlledRange[1] : undefined,\n                    hoverString: this.state.endHoverString,\n                    inputString: this.state.endInputString,\n                    isInputFocused: this.state.isEndInputFocused,\n                    selectedValue: this.state.selectedEnd,\n                },\n            };\n        }\n    };\n\n    private getDateRangeForCallback = (currValue?: moment.Moment, currBoundary?: DateRangeBoundary) => {\n        const otherBoundary = this.getOtherBoundary(currBoundary);\n        const otherValue = this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n        const currDate = this.getDateForCallback(currValue);\n        const otherDate = this.getDateForCallback(otherValue);\n\n        return currBoundary === DateRangeBoundary.START ? [currDate, otherDate] : [otherDate, currDate];\n    };\n\n    private getDateForCallback = (momentDate: moment.Moment) => {\n        if (isMomentNull(momentDate)) {\n            return null;\n        } else if (!momentDate.isValid()) {\n            return new Date(undefined);\n        } else {\n            return fromMomentToDate(momentDate);\n        }\n    };\n\n    private getOtherBoundary = (boundary?: DateRangeBoundary) => {\n        return boundary === DateRangeBoundary.START ? DateRangeBoundary.END : DateRangeBoundary.START;\n    };\n\n    private doBoundaryDatesOverlap = (boundaryDate: moment.Moment, boundary: DateRangeBoundary) => {\n        const { allowSingleDayRange } = this.props;\n\n        const otherBoundary = this.getOtherBoundary(boundary);\n        const otherBoundaryDate = this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n        if (boundary === DateRangeBoundary.START) {\n            return allowSingleDayRange\n                ? boundaryDate.isAfter(otherBoundaryDate, \"day\")\n                : boundaryDate.isSameOrAfter(otherBoundaryDate, \"day\");\n        } else {\n            return allowSingleDayRange\n                ? boundaryDate.isBefore(otherBoundaryDate, \"day\")\n                : boundaryDate.isSameOrBefore(otherBoundaryDate, \"day\");\n        }\n    };\n\n    /**\n     * Returns true if the provided boundary is an END boundary overlapping the\n     * selected start date. (If the boundaries overlap, we consider the END\n     * boundary to be erroneous.)\n     */\n    private doesEndBoundaryOverlapStartBoundary = (boundaryDate: moment.Moment, boundary: DateRangeBoundary) => {\n        return boundary === DateRangeBoundary.START ? false : this.doBoundaryDatesOverlap(boundaryDate, boundary);\n    };\n\n    private isControlled = () => {\n        return this.props.value !== undefined;\n    };\n\n    private isInputEmpty = (inputString: string) => {\n        return inputString == null || inputString.length === 0;\n    };\n\n    private isInputInErrorState = (boundary: DateRangeBoundary) => {\n        const values = this.getStateKeysAndValuesForBoundary(boundary).values;\n        const { isInputFocused, hoverString, inputString, selectedValue } = values;\n\n        const boundaryValue = isInputFocused ? this.dateStringToMoment(inputString) : selectedValue;\n\n        if (hoverString != null) {\n            // don't show an error state while we're hovering over a valid date.\n            return false;\n        } else if (isMomentNull(boundaryValue)) {\n            return false;\n        } else if (!boundaryValue.isValid()) {\n            return true;\n        } else if (!this.isMomentInRange(boundaryValue)) {\n            return true;\n        } else if (this.doesEndBoundaryOverlapStartBoundary(boundaryValue, boundary)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    private isMomentValidAndInRange = (momentDate: moment.Moment) => {\n        return isMomentValidAndInRange(momentDate, this.props.minDate, this.props.maxDate);\n    };\n\n    private isMomentInRange = (momentDate: moment.Moment) => {\n        return isMomentInRange(momentDate, this.props.minDate, this.props.maxDate);\n    };\n\n    private isNextDateRangeValid(nextMomentDate: moment.Moment, boundary: DateRangeBoundary) {\n        return this.isMomentValidAndInRange(nextMomentDate) && !this.doBoundaryDatesOverlap(nextMomentDate, boundary);\n    }\n\n    // this is a slightly kludgy function, but it saves us a good amount of repeated code between\n    // the constructor and componentWillReceiveProps.\n    private getFormattedMinMaxDateString(props: IDateRangeInputProps, propName: \"minDate\" | \"maxDate\") {\n        const date = props[propName];\n        const defaultDate = DateRangeInput.defaultProps[propName];\n        // default values are applied only if a prop is strictly `undefined`\n        // See: https://facebook.github.io/react/docs/react-component.html#defaultprops\n        return this.getFormattedDateString(moment(date === undefined ? defaultDate : date), props.format);\n    }\n}\n"]}