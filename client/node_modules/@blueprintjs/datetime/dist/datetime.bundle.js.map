{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 64f3b05081eb8263d6e5","webpack:///./packages/datetime/dist/index.js","webpack:///./packages/datetime/dist/common/classes.js","webpack:///external \"DayPicker\"","webpack:///./packages/datetime/dist/common/dateUtils.js","webpack:///external \"moment\"","webpack:///./packages/datetime/dist/dateInput.js","webpack:///./packages/datetime/~/tslib/tslib.js","webpack:///external \"classNames\"","webpack:///external \"React\"","webpack:///external \"Blueprint.Core\"","webpack:///./packages/datetime/dist/common/errors.js","webpack:///./packages/datetime/dist/datePicker.js","webpack:///./packages/datetime/dist/datePickerCaption.js","webpack:///./packages/datetime/dist/common/utils.js","webpack:///./packages/datetime/dist/datePickerCore.js","webpack:///./packages/datetime/dist/dateTimePicker.js","webpack:///./packages/datetime/dist/timePicker.js","webpack:///./packages/datetime/dist/dateRangeInput.js","webpack:///./packages/datetime/dist/dateRangePicker.js","webpack:///./packages/datetime/dist/common/monthAndYear.js","webpack:///./packages/datetime/dist/dateRangeSelectionStrategy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChCA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrCA,gD;;;;;;ACAA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,EAAC,kFAAkF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAmE,kDAAkD;AACrH,oEAAmE,kDAAkD;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9QA,gD;;;;;;ACAA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAgF;AAChF;AACA,6BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,2DAA2D;AAC3F;AACA;AACA,iCAAgC,wCAAwC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,+DAA+D;AAC/F;AACA;AACA,iCAAgC,iDAAiD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,yCAAyC;AAC7E;AACA;AACA,qCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,yDAAyD;AAC7F;AACA;AACA,qCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,gEAAgE;AACpG;AACA;AACA,qCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wIAAuI,eAAe,oDAAoD,6DAA6D,mGAAmG,sCAAsC,EAAE;AAClZ;AACA,iFAAgF,8DAA8D;AAC9I;AACA;AACA;AACA;AACA,UAAS;AACT,uEAAsE,wGAAwG,iBAAiB,wLAAwL;AACvX,sEAAqE,6FAA6F,mBAAmB,sPAAsP;AAC3a;AACA;AACA;AACA;AACA,4BAA2B,uDAAuD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAuE;AACvE;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;iECjOA;AACA;AACA,gEAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyD,wDAAwD,EAAE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,qDAAqD;AACtF;AACA,EAAC;AACD;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;;AAEhF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA,iDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iEAAgE,cAAc;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAgD,QAAQ;AACxD;AACA;;AAEA;AACA,wCAAuC,oCAAoC;AAC3E;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wCAAuC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACrG,uCAAsC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACxG,oCAAmC,iEAAiE,uBAAuB,EAAE,4BAA4B;AACzJ;AACA,UAAS;AACT;;AAEA;AACA,kBAAiB,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AAC5G,qBAAoB,qDAAqD,oEAAoE,aAAa,EAAE;AAC5J,2BAA0B,sBAAsB,qBAAqB,GAAG;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C,uCAAsC,SAAS;AAC/C,uCAAsC,WAAW,UAAU;AAC3D,8CAA6C,cAAc;AAC3D;AACA,kHAAiH,OAAO,UAAU;AAClI,qFAAoF,iBAAiB,OAAO;AAC5G,6DAA4D,gBAAgB,QAAQ,OAAO;AAC3F,mDAAkD,gBAAgB,gBAAgB,OAAO;AACzF;AACA,sCAAqC;AACrC;AACA;AACA,cAAa,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AACpE,wCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,MAAM,gBAAgB;AAC7C;AACA;AACA;AACA;AACA,sBAAqB,sBAAsB;AAC3C;AACA;AACA;;AAEA;AACA,iCAAgC,sBAAsB;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,sFAAsF,aAAa,EAAE;AAC1H,2BAA0B,gCAAgC,qCAAqC,0CAA0C,EAAE,EAAE,GAAG;AAChJ,gCAA+B,MAAM,eAAe,EAAE,YAAY,oBAAoB,EAAE;AACxF,2BAA0B,oGAAoG;AAC9H,kCAAiC,uBAAuB;AACxD,iCAAgC,wBAAwB;AACxD,gCAA+B,yDAAyD;AACxF;;AAEA;AACA;AACA,sBAAqB,4CAA4C,SAAS,EAAE,qDAAqD,aAAa,EAAE;AAChJ,8BAA6B,gCAAgC,oBAAoB,gDAAgD,gBAAgB,GAAG;AACpJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,E;;;;;;;ACjND,gD;;;;;;ACAA,gD;;;;;;ACAA,iC;;;;;;ACAA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvBA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,iFAAiF;AAC9H;AACA;AACA;AACA;AACA,iDAAgD,uFAAuF,UAAU,uJAAuJ,IAAI;AAC5S;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,uDAAuD;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,6BAA6B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,uDAAuD;AAC1G;AACA;AACA;AACA,iCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,+FAA+F;AAC/H;AACA;AACA,iCAAgC,iFAAiF;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,uDAAuD;AACnG,mEAAkE,0FAA0F,mBAAmB,mSAAmS;AACld;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,uCAAuC;AACnF,iDAAgD,qGAAqG;AACrJ,iDAAgD,qGAAqG;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnPA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD,qCAAqC;AACvF,oDAAmD,sCAAsC;AACzF,mDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,8BAA8B;AACjF,UAAS;AACT;AACA;AACA,qCAAoC,iBAAiB;AACrD;AACA;AACA;AACA,oDAAmD,iCAAiC;AACpF,UAAS;AACT;AACA;AACA,oEAAmE,6DAA6D;AAChI;AACA;AACA;AACA;AACA,6CAA4C,uEAAuE;AACnH,yCAAwC,+CAA+C;AACvF,gDAA+C,qHAAqH;AACpK,8CAA6C,0DAA0D;AACvG,yCAAwC,+CAA+C;AACvF,gDAA+C,kHAAkH;AACjK,8CAA6C,yDAAyD;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;AAEA;;;;;;;ACvFA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,gCAA+B,gBAAgB;AAC/C,uCAAsC,kCAAkC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrCA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA,0DAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtDA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,sEAAsE;AAClH,6EAA4E,+BAA+B,iGAAiG;AAC5M,6EAA4E,+BAA+B,gDAAgD;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvEA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,wFAAwF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD;AACrD;AACA;AACA,WAAU;AACV,wDAAuD;AACvD,mCAAkC,IAAI;AACtC,qCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,iBAAiB;AAC5D;AACA;AACA,4CAA2C,mBAAmB;AAC9D;AACA;AACA,4CAA2C,mBAAmB;AAC9D;AACA;AACA,4CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA,WAAU;AACV,yDAAwD;AACxD,uCAAsC;AACtC,yDAAwD,kCAAkC,EAAE;AAC5F,2DAA0D,kCAAkC,EAAE;AAC9F;AACA;AACA,kBAAiB;AACjB;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAmF;AACnF;AACA;AACA;AACA,6CAA4C,qBAAqB;AACjE,yCAAwC,0CAA0C;AAClF;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,yCAAwC,0CAA0C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,0CAA0C;AAClF;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,2EAA0E,uCAAuC;AACjH;AACA;AACA,+BAA8B,YAAY;AAC1C,6CAA4C,6CAA6C;AACzF;AACA;AACA,+CAA8C,uQAAuQ;AACrT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,aAAa,2CAA2C;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,uBAAuB;AAC3D,gDAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9XA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA,8EAA6E,sBAAsB,cAAc,0WAA0W;AAC3d;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD,oBAAoB,yDAAyD;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,6BAA4B,sCAAsC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,oDAAmD,qBAAqB;AACxE;AACA;AACA,oDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA,oDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA,oDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA,oDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA,oDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,qBAAqB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAwG,eAAe,kLAAkL;AACzS;AACA;AACA,uEAAsE,iFAAiF,4BAA4B,mGAAmG;AACtR,yCAAwC,0CAA0C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,cAAc,yDAAyD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,cAAc,iDAAiD;AAC1G;AACA;AACA;AACA,4CAA2C,cAAc,iDAAiD;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA,wBAAuB;AACvB;AACA;AACA;;AAEA;;;;;;;ACxoBA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA,cAAa;AACb,uFAAsF,wDAAwD,EAAE;AAChJ,qFAAoF,wDAAwD,EAAE;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,8CAA6C,iFAAiF;AAC9H;AACA;AACA;AACA;AACA,8DAA6D,uFAAuF,iBAAiB,+JAA+J,IAAI;AACxU,4DAA2D,uFAAuF,iBAAiB,+LAA+L,IAAI;AACtW,6DAA4D,uFAAuF,iBAAiB,6LAA6L,IAAI;AACrW;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA,mCAAkC,mBAAmB,oLAAoL;AACzO;AACA,8GAA6G;AAC7G;AACA;AACA;AACA;AACA,iDAAgD,qBAAqB;AACrE;AACA,wEAAuE,uBAAuB,sMAAsM;AACpS;AACA;AACA,iDAAgD,wFAAwF;AACxI;AACA,wEAAuE,uBAAuB,+MAA+M;AAC7S,wEAAuE,uBAAuB,8MAA8M;AAC5S;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D,iLAAiL;AAC3O,UAAS;AACT,kDAAiD,mDAAmD;AACpG;AACA;AACA;AACA,6BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,mCAAmC,EAAE;AACjF,8CAA6C,qCAAqC,EAAE;AACpF,iDAAgD,qCAAqC,EAAE;AACvF,+CAA8C,qCAAqC,EAAE;AACrF,6CAA4C,2CAA2C,EAAE;AACzF,8CAA6C,2CAA2C,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChbA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClEA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;AAEA","file":"datetime.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"DayPicker\"), require(\"moment\"), require(\"classNames\"), require(\"React\"), require(\"Blueprint.Core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"DayPicker\", \"moment\", \"classNames\", \"React\", \"Blueprint.Core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Datetime\"] = factory(require(\"DayPicker\"), require(\"moment\"), require(\"classNames\"), require(\"React\"), require(\"Blueprint.Core\"));\n\telse\n\t\troot[\"Blueprint\"] = root[\"Blueprint\"] || {}, root[\"Blueprint\"][\"Datetime\"] = factory(root[\"DayPicker\"], root[\"moment\"], root[\"classNames\"], root[\"React\"], root[\"Blueprint.Core\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 64f3b05081eb8263d6e5","/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar classes = require(\"./common/classes\");\n// re-exporting these symbols to preserve compatility\nvar react_day_picker_1 = require(\"react-day-picker\");\nexports.IDatePickerLocaleUtils = react_day_picker_1.LocaleUtils;\nexports.Classes = classes;\nvar dateUtils_1 = require(\"./common/dateUtils\");\nexports.DateRangeBoundary = dateUtils_1.DateRangeBoundary;\nvar dateInput_1 = require(\"./dateInput\");\nexports.DateInput = dateInput_1.DateInput;\nvar datePicker_1 = require(\"./datePicker\");\nexports.DatePicker = datePicker_1.DatePicker;\nexports.DatePickerFactory = datePicker_1.DatePickerFactory;\nvar dateTimePicker_1 = require(\"./dateTimePicker\");\nexports.DateTimePicker = dateTimePicker_1.DateTimePicker;\nvar dateRangeInput_1 = require(\"./dateRangeInput\");\nexports.DateRangeInput = dateRangeInput_1.DateRangeInput;\nvar dateRangePicker_1 = require(\"./dateRangePicker\");\nexports.DateRangePicker = dateRangePicker_1.DateRangePicker;\nexports.DateRangePickerFactory = dateRangePicker_1.DateRangePickerFactory;\nvar timePicker_1 = require(\"./timePicker\");\nexports.TimePicker = timePicker_1.TimePicker;\nexports.TimePickerFactory = timePicker_1.TimePickerFactory;\nexports.TimePickerPrecision = timePicker_1.TimePickerPrecision;\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/index.js\n// module id = 0\n// module chunks = 0","/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DATEPICKER = \"pt-datepicker\";\nexports.DATEPICKER_CAPTION = \"pt-datepicker-caption\";\nexports.DATEPICKER_CAPTION_CARET = \"pt-datepicker-caption-caret\";\nexports.DATEPICKER_CAPTION_SELECT = \"pt-datepicker-caption-select\";\nexports.DATEPICKER_DAY = \"DayPicker-Day\";\nexports.DATEPICKER_DAY_DISABLED = \"DayPicker-Day--disabled\";\nexports.DATEPICKER_DAY_OUTSIDE = \"DayPicker-Day--outside\";\nexports.DATEPICKER_DAY_SELECTED = \"DayPicker-Day--selected\";\nexports.DATEPICKER_FOOTER = \"pt-datepicker-footer\";\nexports.DATEPICKER_MONTH_SELECT = \"pt-datepicker-month-select\";\nexports.DATEPICKER_YEAR_SELECT = \"pt-datepicker-year-select\";\nexports.DATERANGEPICKER = \"pt-daterangepicker\";\nexports.DATERANGEPICKER_CONTIGUOUS = \"pt-daterangepicker-contiguous\";\nexports.DATERANGEPICKER_SINGLE_MONTH = \"pt-daterangepicker-single-month\";\nexports.DATERANGEPICKER_DAY_SELECTED_RANGE = \"DayPicker-Day--selected-range\";\nexports.DATERANGEPICKER_DAY_HOVERED_RANGE = \"DayPicker-Day--hovered-range\";\nexports.DATERANGEPICKER_SHORTCUTS = \"pt-daterangepicker-shortcuts\";\nexports.DATETIMEPICKER = \"pt-datetimepicker\";\nexports.TIMEPICKER = \"pt-timepicker\";\nexports.TIMEPICKER_ARROW_BUTTON = \"pt-timepicker-arrow-button\";\nexports.TIMEPICKER_ARROW_ROW = \"pt-timepicker-arrow-row\";\nexports.TIMEPICKER_DIVIDER_TEXT = \"pt-timepicker-divider-text\";\nexports.TIMEPICKER_HOUR = \"pt-timepicker-hour\";\nexports.TIMEPICKER_INPUT = \"pt-timepicker-input\";\nexports.TIMEPICKER_INPUT_ROW = \"pt-timepicker-input-row\";\nexports.TIMEPICKER_MILLISECOND = \"pt-timepicker-millisecond\";\nexports.TIMEPICKER_MINUTE = \"pt-timepicker-minute\";\nexports.TIMEPICKER_SECOND = \"pt-timepicker-second\";\n\n//# sourceMappingURL=classes.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/common/classes.js\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"DayPicker\"\n// module id = 2\n// module chunks = 0","/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar moment = require(\"moment\");\nvar DateRangeBoundary;\n(function (DateRangeBoundary) {\n    DateRangeBoundary[DateRangeBoundary[\"START\"] = 0] = \"START\";\n    DateRangeBoundary[DateRangeBoundary[\"END\"] = 1] = \"END\";\n})(DateRangeBoundary = exports.DateRangeBoundary || (exports.DateRangeBoundary = {}));\nfunction areEqual(date1, date2) {\n    if (date1 == null && date2 == null) {\n        return true;\n    }\n    else if (date1 == null || date2 == null) {\n        return false;\n    }\n    else {\n        return date1.getTime() === date2.getTime();\n    }\n}\nexports.areEqual = areEqual;\nfunction areRangesEqual(dateRange1, dateRange2) {\n    if (dateRange1 == null && dateRange2 == null) {\n        return true;\n    }\n    else if (dateRange1 == null || dateRange2 == null) {\n        return false;\n    }\n    else {\n        var start1 = dateRange1[0], end1 = dateRange1[1];\n        var start2 = dateRange2[0], end2 = dateRange2[1];\n        var areStartsEqual = (start1 == null && start2 == null) || areSameDay(start1, start2);\n        var areEndsEqual = (end1 == null && end2 == null) || areSameDay(end1, end2);\n        return areStartsEqual && areEndsEqual;\n    }\n}\nexports.areRangesEqual = areRangesEqual;\nfunction areSameDay(date1, date2) {\n    return (date1 != null &&\n        date2 != null &&\n        date1.getDate() === date2.getDate() &&\n        date1.getMonth() === date2.getMonth() &&\n        date1.getFullYear() === date2.getFullYear());\n}\nexports.areSameDay = areSameDay;\nfunction areSameMonth(date1, date2) {\n    return (date1 != null &&\n        date2 != null &&\n        date1.getMonth() === date2.getMonth() &&\n        date1.getFullYear() === date2.getFullYear());\n}\nexports.areSameMonth = areSameMonth;\nfunction areSameTime(date1, date2) {\n    return (date1 != null &&\n        date2 != null &&\n        date1.getHours() === date2.getHours() &&\n        date1.getMinutes() === date2.getMinutes() &&\n        date1.getSeconds() === date2.getSeconds() &&\n        date1.getMilliseconds() === date2.getMilliseconds());\n}\nexports.areSameTime = areSameTime;\nfunction clone(d) {\n    return new Date(d.getTime());\n}\nexports.clone = clone;\nfunction isDayInRange(date, dateRange, exclusive) {\n    if (exclusive === void 0) { exclusive = false; }\n    if (date == null) {\n        return false;\n    }\n    var day = clone(date);\n    var start = clone(dateRange[0]);\n    var end = clone(dateRange[1]);\n    day.setHours(0, 0, 0, 0);\n    start.setHours(0, 0, 0, 0);\n    end.setHours(0, 0, 0, 0);\n    return start <= day && day <= end && (!exclusive || (!areSameDay(start, day) && !areSameDay(day, end)));\n}\nexports.isDayInRange = isDayInRange;\nfunction isDayRangeInRange(innerRange, outerRange) {\n    return ((innerRange[0] == null || isDayInRange(innerRange[0], outerRange)) &&\n        (innerRange[1] == null || isDayInRange(innerRange[1], outerRange)));\n}\nexports.isDayRangeInRange = isDayRangeInRange;\nfunction isMonthInRange(date, dateRange) {\n    if (date == null) {\n        return false;\n    }\n    var day = clone(date);\n    var start = clone(dateRange[0]);\n    var end = clone(dateRange[1]);\n    day.setDate(1);\n    start.setDate(1);\n    end.setDate(1);\n    day.setHours(0, 0, 0, 0);\n    start.setHours(0, 0, 0, 0);\n    end.setHours(0, 0, 0, 0);\n    return start <= day && day <= end;\n}\nexports.isMonthInRange = isMonthInRange;\nexports.isTimeEqualOrGreaterThan = function (time, timeToCompare) { return time.getTime() >= timeToCompare.getTime(); };\nexports.isTimeEqualOrSmallerThan = function (time, timeToCompare) { return time.getTime() <= timeToCompare.getTime(); };\nfunction isTimeInRange(date, minDate, maxDate) {\n    var time = getDateOnlyWithTime(date);\n    var minTime = getDateOnlyWithTime(minDate);\n    var maxTime = getDateOnlyWithTime(maxDate);\n    var isTimeGreaterThanMinTime = exports.isTimeEqualOrGreaterThan(time, minTime);\n    var isTimeSmallerThanMaxTime = exports.isTimeEqualOrSmallerThan(time, maxTime);\n    if (exports.isTimeEqualOrSmallerThan(maxTime, minTime)) {\n        return isTimeGreaterThanMinTime || isTimeSmallerThanMaxTime;\n    }\n    return isTimeGreaterThanMinTime && isTimeSmallerThanMaxTime;\n}\nexports.isTimeInRange = isTimeInRange;\nfunction getTimeInRange(time, minTime, maxTime) {\n    if (areSameTime(minTime, maxTime)) {\n        return maxTime;\n    }\n    else if (isTimeInRange(time, minTime, maxTime)) {\n        return time;\n    }\n    else if (isTimeSameOrAfter(time, maxTime)) {\n        return maxTime;\n    }\n    return minTime;\n}\nexports.getTimeInRange = getTimeInRange;\n/**\n * Returns true if the time part of `date` is later than or equal to the time\n * part of `dateToCompare`. The day, month, and year parts will not be compared.\n */\nfunction isTimeSameOrAfter(date, dateToCompare) {\n    var time = getDateOnlyWithTime(date);\n    var timeToCompare = getDateOnlyWithTime(dateToCompare);\n    return exports.isTimeEqualOrGreaterThan(time, timeToCompare);\n}\nexports.isTimeSameOrAfter = isTimeSameOrAfter;\n/**\n * @returns a Date at the exact time-wise midpoint between startDate and endDate\n */\nfunction getDateBetween(dateRange) {\n    var start = dateRange[0].getTime();\n    var end = dateRange[1].getTime();\n    var middle = start + (end - start) * 0.5;\n    return new Date(middle);\n}\nexports.getDateBetween = getDateBetween;\nfunction getDateTime(date, time) {\n    if (date === null) {\n        return null;\n    }\n    else if (time === null) {\n        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);\n    }\n    else {\n        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());\n    }\n}\nexports.getDateTime = getDateTime;\nfunction getDateOnlyWithTime(date) {\n    return new Date(0, 0, 0, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\nexports.getDateOnlyWithTime = getDateOnlyWithTime;\nfunction isMomentNull(momentDate) {\n    return momentDate.parsingFlags().nullInput;\n}\nexports.isMomentNull = isMomentNull;\nfunction isMomentValidAndInRange(momentDate, minDate, maxDate) {\n    return momentDate.isValid() && isMomentInRange(momentDate, minDate, maxDate);\n}\nexports.isMomentValidAndInRange = isMomentValidAndInRange;\nfunction isMomentInRange(momentDate, minDate, maxDate) {\n    return momentDate.isBetween(minDate, maxDate, \"day\", \"[]\");\n}\nexports.isMomentInRange = isMomentInRange;\n/**\n * Translate a Date object into a moment, adjusting the local timezone into the moment one.\n * This is a no-op unless moment-timezone's setDefault has been called.\n */\nfunction fromDateToMoment(date) {\n    if (date == null) {\n        // moment(undefined) is equivalent to moment(), which returns the current date and time when\n        // invoked. thus, we need to explicitly return moment(null).\n        return moment(null);\n    }\n    else if (typeof date === \"string\") {\n        return moment(date);\n    }\n    else {\n        return moment([\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            date.getMilliseconds(),\n        ]);\n    }\n}\nexports.fromDateToMoment = fromDateToMoment;\n/**\n * Translate a moment into a Date object, adjusting the moment timezone into the local one.\n * This is a no-op unless moment-timezone's setDefault has been called.\n */\nfunction fromMomentToDate(momentDate) {\n    if (momentDate == null) {\n        return undefined;\n    }\n    else {\n        return new Date(momentDate.year(), momentDate.month(), momentDate.date(), momentDate.hours(), momentDate.minutes(), momentDate.seconds(), momentDate.milliseconds());\n    }\n}\nexports.fromMomentToDate = fromMomentToDate;\n/**\n * Translate a DateRange into a MomentDateRange, adjusting the local timezone\n * into the moment one (a no-op unless moment-timezone's setDefault has been\n * called).\n */\nfunction fromDateRangeToMomentDateRange(dateRange) {\n    if (dateRange == null) {\n        return undefined;\n    }\n    return [fromDateToMoment(dateRange[0]), fromDateToMoment(dateRange[1])];\n}\nexports.fromDateRangeToMomentDateRange = fromDateRangeToMomentDateRange;\n/**\n * Translate a MomentDateRange into a DateRange, adjusting the moment timezone\n * into the local one. This is a no-op unless moment-timezone's setDefault has\n * been called.\n */\nfunction fromMomentDateRangeToDateRange(momentDateRange) {\n    if (momentDateRange == null) {\n        return undefined;\n    }\n    return [fromMomentToDate(momentDateRange[0]), fromMomentToDate(momentDateRange[1])];\n}\nexports.fromMomentDateRangeToDateRange = fromMomentDateRangeToDateRange;\nfunction getDatePreviousMonth(date) {\n    if (date.getMonth() === 0 /* JANUARY */) {\n        return new Date(date.getFullYear() - 1, 11 /* DECEMBER */);\n    }\n    else {\n        return new Date(date.getFullYear(), date.getMonth() - 1);\n    }\n}\nexports.getDatePreviousMonth = getDatePreviousMonth;\nfunction getDateNextMonth(date) {\n    if (date.getMonth() === 11 /* DECEMBER */) {\n        return new Date(date.getFullYear() + 1, 0 /* JANUARY */);\n    }\n    else {\n        return new Date(date.getFullYear(), date.getMonth() + 1);\n    }\n}\nexports.getDateNextMonth = getDateNextMonth;\n/**\n * Returns a date string in the provided format localized to the provided locale.\n */\nfunction toLocalizedDateString(momentDate, format, locale) {\n    var adjustedMomentDate = locale != null ? momentDate.locale(locale) : momentDate;\n    return adjustedMomentDate.format(format);\n}\nexports.toLocalizedDateString = toLocalizedDateString;\n\n//# sourceMappingURL=dateUtils.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/common/dateUtils.js\n// module id = 3\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment\"\n// module id = 4\n// module chunks = 0","/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar classNames = require(\"classnames\");\nvar moment = require(\"moment\");\nvar React = require(\"react\");\nvar core_1 = require(\"@blueprintjs/core\");\nvar dateUtils_1 = require(\"./common/dateUtils\");\nvar errors_1 = require(\"./common/errors\");\nvar datePicker_1 = require(\"./datePicker\");\nvar datePickerCore_1 = require(\"./datePickerCore\");\nvar dateTimePicker_1 = require(\"./dateTimePicker\");\nvar DateInput = (function (_super) {\n    tslib_1.__extends(DateInput, _super);\n    function DateInput(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.inputRef = null;\n        _this.getDateString = function (value) {\n            if (dateUtils_1.isMomentNull(value)) {\n                return \"\";\n            }\n            if (value.isValid()) {\n                if (_this.isMomentInRange(value)) {\n                    return dateUtils_1.toLocalizedDateString(value, _this.props.format, _this.props.locale);\n                }\n                else {\n                    return _this.props.outOfRangeMessage;\n                }\n            }\n            return _this.props.invalidDateMessage;\n        };\n        _this.handleClosePopover = function (e) {\n            var _a = _this.props.popoverProps, popoverProps = _a === void 0 ? {} : _a;\n            core_1.Utils.safeInvoke(popoverProps.onClose, e);\n            _this.setState({ isOpen: false });\n        };\n        _this.handleDateChange = function (date, hasUserManuallySelectedDate) {\n            var prevMomentDate = _this.state.value;\n            var momentDate = dateUtils_1.fromDateToMoment(date);\n            // this change handler was triggered by a change in month, day, or (if enabled) time. for UX\n            // purposes, we want to close the popover only if the user explicitly clicked a day within\n            // the current month.\n            var isOpen = !hasUserManuallySelectedDate ||\n                _this.hasMonthChanged(prevMomentDate, momentDate) ||\n                _this.hasTimeChanged(prevMomentDate, momentDate) ||\n                !_this.props.closeOnSelection;\n            if (_this.props.value === undefined) {\n                _this.setState({ isInputFocused: false, isOpen: isOpen, value: momentDate });\n            }\n            else {\n                _this.setState({ isInputFocused: false, isOpen: isOpen });\n            }\n            core_1.Utils.safeInvoke(_this.props.onChange, date === null ? null : dateUtils_1.fromMomentToDate(momentDate));\n        };\n        _this.handleInputFocus = function (e) {\n            var valueString;\n            if (dateUtils_1.isMomentNull(_this.state.value)) {\n                valueString = \"\";\n            }\n            else {\n                valueString = dateUtils_1.toLocalizedDateString(_this.state.value, _this.props.format, _this.props.locale);\n            }\n            if (_this.props.openOnFocus) {\n                _this.setState({ isInputFocused: true, isOpen: true, valueString: valueString });\n            }\n            else {\n                _this.setState({ isInputFocused: true, valueString: valueString });\n            }\n            _this.safeInvokeInputProp(\"onFocus\", e);\n        };\n        _this.handleInputClick = function (e) {\n            if (_this.props.openOnFocus) {\n                e.stopPropagation();\n            }\n            _this.safeInvokeInputProp(\"onClick\", e);\n        };\n        _this.handleInputChange = function (e) {\n            var valueString = e.target.value;\n            var value = _this.createMoment(valueString);\n            if (value.isValid() && _this.isMomentInRange(value)) {\n                if (_this.props.value === undefined) {\n                    _this.setState({ value: value, valueString: valueString });\n                }\n                else {\n                    _this.setState({ valueString: valueString });\n                }\n                core_1.Utils.safeInvoke(_this.props.onChange, dateUtils_1.fromMomentToDate(value));\n            }\n            else {\n                if (valueString.length === 0) {\n                    core_1.Utils.safeInvoke(_this.props.onChange, null);\n                }\n                _this.setState({ valueString: valueString });\n            }\n            _this.safeInvokeInputProp(\"onChange\", e);\n        };\n        _this.handleInputBlur = function (e) {\n            var valueString = _this.state.valueString;\n            var value = _this.createMoment(valueString);\n            if (valueString.length > 0 &&\n                valueString !== _this.getDateString(_this.state.value) &&\n                (!value.isValid() || !_this.isMomentInRange(value))) {\n                if (_this.props.value === undefined) {\n                    _this.setState({ isInputFocused: false, value: value, valueString: null });\n                }\n                else {\n                    _this.setState({ isInputFocused: false });\n                }\n                if (!value.isValid()) {\n                    core_1.Utils.safeInvoke(_this.props.onError, new Date(undefined));\n                }\n                else if (!_this.isMomentInRange(value)) {\n                    core_1.Utils.safeInvoke(_this.props.onError, dateUtils_1.fromMomentToDate(value));\n                }\n                else {\n                    core_1.Utils.safeInvoke(_this.props.onChange, dateUtils_1.fromMomentToDate(value));\n                }\n            }\n            else {\n                if (valueString.length === 0) {\n                    _this.setState({ isInputFocused: false, value: moment(null), valueString: null });\n                }\n                else {\n                    _this.setState({ isInputFocused: false });\n                }\n            }\n            _this.safeInvokeInputProp(\"onBlur\", e);\n        };\n        _this.setInputRef = function (el) {\n            _this.inputRef = el;\n            var _a = _this.props.inputProps, inputProps = _a === void 0 ? {} : _a;\n            core_1.Utils.safeInvoke(inputProps.inputRef, el);\n        };\n        var defaultValue = _this.props.defaultValue ? dateUtils_1.fromDateToMoment(_this.props.defaultValue) : moment(null);\n        _this.state = {\n            isInputFocused: false,\n            isOpen: false,\n            value: _this.props.value !== undefined ? dateUtils_1.fromDateToMoment(_this.props.value) : defaultValue,\n            valueString: null,\n        };\n        return _this;\n    }\n    DateInput.prototype.render = function () {\n        var _a = this.state, value = _a.value, valueString = _a.valueString;\n        var dateString = this.state.isInputFocused ? valueString : this.getDateString(value);\n        var date = this.state.isInputFocused ? this.createMoment(valueString) : value;\n        var dateValue = this.isMomentValidAndInRange(value) ? dateUtils_1.fromMomentToDate(value) : null;\n        var popoverContent = this.props.timePrecision === undefined ? (React.createElement(datePicker_1.DatePicker, tslib_1.__assign({}, this.props, { onChange: this.handleDateChange, value: dateValue }))) : (React.createElement(dateTimePicker_1.DateTimePicker, { onChange: this.handleDateChange, value: dateValue, datePickerProps: this.props, timePickerProps: { precision: this.props.timePrecision } }));\n        // assign default empty object here to prevent mutation\n        var _b = this.props, _c = _b.inputProps, inputProps = _c === void 0 ? {} : _c, _d = _b.popoverProps, popoverProps = _d === void 0 ? {} : _d;\n        // exclude ref (comes from HTMLInputProps typings, not InputGroup)\n        var ref = inputProps.ref, htmlInputProps = tslib_1.__rest(inputProps, [\"ref\"]);\n        var inputClasses = classNames({\n            \"pt-intent-danger\": !(this.isMomentValidAndInRange(date) || dateUtils_1.isMomentNull(date) || dateString === \"\"),\n        }, inputProps.className);\n        return (React.createElement(core_1.Popover, tslib_1.__assign({ inline: true, isOpen: this.state.isOpen && !this.props.disabled, position: this.props.popoverPosition }, popoverProps, { autoFocus: false, enforceFocus: false, content: popoverContent, onClose: this.handleClosePopover, popoverClassName: classNames(\"pt-dateinput-popover\", popoverProps.popoverClassName) }),\n            React.createElement(core_1.InputGroup, tslib_1.__assign({ autoComplete: \"off\", placeholder: this.props.format, rightElement: this.props.rightElement }, htmlInputProps, { className: inputClasses, disabled: this.props.disabled, inputRef: this.setInputRef, type: \"text\", onBlur: this.handleInputBlur, onChange: this.handleInputChange, onClick: this.handleInputClick, onFocus: this.handleInputFocus, value: dateString }))));\n    };\n    DateInput.prototype.componentWillReceiveProps = function (nextProps) {\n        _super.prototype.componentWillReceiveProps.call(this, nextProps);\n        if (nextProps.value !== this.props.value) {\n            this.setState({ value: dateUtils_1.fromDateToMoment(nextProps.value) });\n        }\n    };\n    DateInput.prototype.validateProps = function (props) {\n        if (props.popoverPosition !== DateInput.defaultProps.popoverPosition) {\n            console.warn(errors_1.DATEINPUT_WARN_DEPRECATED_POPOVER_POSITION);\n        }\n        if (props.openOnFocus !== DateInput.defaultProps.openOnFocus) {\n            console.warn(errors_1.DATEINPUT_WARN_DEPRECATED_OPEN_ON_FOCUS);\n        }\n    };\n    DateInput.prototype.createMoment = function (valueString) {\n        // Locale here used for parsing, does not set the locale on the moment itself\n        return moment(valueString, this.props.format, this.props.locale);\n    };\n    DateInput.prototype.isMomentValidAndInRange = function (value) {\n        return dateUtils_1.isMomentValidAndInRange(value, this.props.minDate, this.props.maxDate);\n    };\n    DateInput.prototype.isMomentInRange = function (value) {\n        return dateUtils_1.isMomentInRange(value, this.props.minDate, this.props.maxDate);\n    };\n    DateInput.prototype.shouldCheckForDateChanges = function (prevMomentDate, nextMomentDate) {\n        return nextMomentDate != null && !dateUtils_1.isMomentNull(prevMomentDate) && prevMomentDate.isValid();\n    };\n    DateInput.prototype.hasMonthChanged = function (prevMomentDate, nextMomentDate) {\n        return (this.shouldCheckForDateChanges(prevMomentDate, nextMomentDate) &&\n            nextMomentDate.month() !== prevMomentDate.month());\n    };\n    DateInput.prototype.hasTimeChanged = function (prevMomentDate, nextMomentDate) {\n        return (this.shouldCheckForDateChanges(prevMomentDate, nextMomentDate) &&\n            this.props.timePrecision != null &&\n            (nextMomentDate.hours() !== prevMomentDate.hours() ||\n                nextMomentDate.minutes() !== prevMomentDate.minutes() ||\n                nextMomentDate.seconds() !== prevMomentDate.seconds() ||\n                nextMomentDate.milliseconds() !== prevMomentDate.milliseconds()));\n    };\n    /** safe wrapper around invoking input props event handler (prop defaults to undefined) */\n    DateInput.prototype.safeInvokeInputProp = function (name, e) {\n        var _a = this.props.inputProps, inputProps = _a === void 0 ? {} : _a;\n        core_1.Utils.safeInvoke(inputProps[name], e);\n    };\n    return DateInput;\n}(core_1.AbstractComponent));\nDateInput.defaultProps = {\n    closeOnSelection: true,\n    dayPickerProps: {},\n    disabled: false,\n    format: \"YYYY-MM-DD\",\n    invalidDateMessage: \"Invalid date\",\n    maxDate: datePickerCore_1.getDefaultMaxDate(),\n    minDate: datePickerCore_1.getDefaultMinDate(),\n    openOnFocus: true,\n    outOfRangeMessage: \"Out of range\",\n    popoverPosition: core_1.Position.BOTTOM,\n};\nDateInput.displayName = \"Blueprint.DateInput\";\nexports.DateInput = DateInput;\n\n//# sourceMappingURL=dateInput.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/dateInput.js\n// module id = 5\n// module chunks = 0","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [0, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator];\r\n        return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/~/tslib/tslib.js\n// module id = 6\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"classNames\"\n// module id = 7\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"React\"\n// module id = 8\n// module chunks = 0","module.exports = Blueprint.Core;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"Blueprint.Core\"\n// module id = 9\n// module chunks = 0","/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ns = \"[Blueprint]\";\nexports.DATEPICKER_DEFAULT_VALUE_INVALID = ns + \" <DatePicker> defaultValue must be within minDate and maxDate bounds.\";\nexports.DATEPICKER_INITIAL_MONTH_INVALID = ns + \" <DatePicker> initialMonth must be within minDate and maxDate bounds.\";\nexports.DATEPICKER_MAX_DATE_INVALID = ns + \" <DatePicker> maxDate must be later than minDate.\";\nexports.DATEPICKER_VALUE_INVALID = ns + \" <DatePicker> value prop must be within minDate and maxDate bounds.\";\nexports.DATERANGEPICKER_DEFAULT_VALUE_INVALID = exports.DATEPICKER_DEFAULT_VALUE_INVALID.replace(\"DatePicker\", \"DateRangePicker\");\nexports.DATERANGEPICKER_INITIAL_MONTH_INVALID = exports.DATEPICKER_INITIAL_MONTH_INVALID.replace(\"DatePicker\", \"DateRangePicker\");\nexports.DATERANGEPICKER_MAX_DATE_INVALID = exports.DATEPICKER_MAX_DATE_INVALID.replace(\"DatePicker\", \"DateRangePicker\");\nexports.DATERANGEPICKER_VALUE_INVALID = exports.DATEPICKER_VALUE_INVALID.replace(\"DatePicker\", \"DateRangePicker\");\nexports.DATERANGEPICKER_PREFERRED_BOUNDARY_TO_MODIFY_INVALID = \"<DateRangePicker> preferredBoundaryToModify must be a valid DateRangeBoundary if defined.\";\nexports.DATEINPUT_WARN_DEPRECATED_POPOVER_POSITION = ns + \" DEPRECATION: <DateInput> popoverPosition is deprecated. Use popoverProps.position.\";\nexports.DATEINPUT_WARN_DEPRECATED_OPEN_ON_FOCUS = ns + \" DEPRECATION: <DateInput> openOnFocus is deprecated. This feature will be removed in the next major version.\";\nexports.DATERANGEINPUT_NULL_VALUE = ns + \" <DateRangeInput> value cannot be null. Pass undefined to clear the value and operate in \" +\n    \"uncontrolled mode, or pass [null, null] to clear the value and continue operating in controlled mode.\";\n\n//# sourceMappingURL=errors.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/common/errors.js\n// module id = 10\n// module chunks = 0","/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar core_1 = require(\"@blueprintjs/core\");\nvar classNames = require(\"classnames\");\nvar React = require(\"react\");\nvar ReactDayPicker = require(\"react-day-picker\");\nvar Classes = require(\"./common/classes\");\nvar DateUtils = require(\"./common/dateUtils\");\nvar Errors = require(\"./common/errors\");\nvar datePickerCaption_1 = require(\"./datePickerCaption\");\nvar datePickerCore_1 = require(\"./datePickerCore\");\nvar DatePicker = (function (_super) {\n    tslib_1.__extends(DatePicker, _super);\n    function DatePicker(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.ignoreNextMonthChange = false;\n        _this.disabledDays = function (day) { return !DateUtils.isDayInRange(day, [_this.props.minDate, _this.props.maxDate]); };\n        _this.getDisabledDaysModifier = function () {\n            var disabledDays = _this.props.dayPickerProps.disabledDays;\n            return disabledDays instanceof Array ? [_this.disabledDays].concat(disabledDays) : [_this.disabledDays, disabledDays];\n        };\n        _this.renderCaption = function (props) { return (React.createElement(datePickerCaption_1.DatePickerCaption, tslib_1.__assign({}, props, { maxDate: _this.props.maxDate, minDate: _this.props.minDate, onMonthChange: _this.handleMonthSelectChange, onYearChange: _this.handleYearSelectChange }))); };\n        _this.handleDayClick = function (day, modifiers, e) {\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onDayClick, day, modifiers, e);\n            var newValue = day;\n            if (_this.props.canClearSelection && modifiers.selected) {\n                newValue = null;\n            }\n            if (_this.props.value === undefined) {\n                // component is uncontrolled\n                if (!modifiers.disabled) {\n                    var displayMonth = day.getMonth();\n                    var displayYear = day.getFullYear();\n                    var selectedDay = day.getDate();\n                    _this.setState({\n                        displayMonth: displayMonth,\n                        displayYear: displayYear,\n                        selectedDay: selectedDay,\n                        value: newValue,\n                    });\n                }\n            }\n            if (!modifiers.disabled) {\n                core_1.Utils.safeInvoke(_this.props.onChange, newValue, true);\n                if (_this.state.value != null && _this.state.value.getMonth() !== day.getMonth()) {\n                    _this.ignoreNextMonthChange = true;\n                }\n            }\n            else {\n                // rerender base component to get around bug where you can navigate past bounds by clicking days\n                _this.forceUpdate();\n            }\n        };\n        _this.handleMonthChange = function (newDate) {\n            var displayMonth = newDate.getMonth();\n            var displayYear = newDate.getFullYear();\n            var value = _this.state.value;\n            if (value !== null) {\n                value = _this.computeValidDateInSpecifiedMonthYear(displayYear, displayMonth);\n                if (_this.ignoreNextMonthChange) {\n                    _this.ignoreNextMonthChange = false;\n                }\n                else {\n                    // if handleDayClick just got run, it means the user selected a date in a new month,\n                    // so don't run onChange again\n                    core_1.Utils.safeInvoke(_this.props.onChange, value, false);\n                }\n            }\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, value);\n            _this.setStateWithValueIfUncontrolled({ displayMonth: displayMonth, displayYear: displayYear }, value);\n        };\n        _this.handleMonthSelectChange = function (displayMonth) {\n            var value = _this.state.value;\n            if (value !== null) {\n                value = _this.computeValidDateInSpecifiedMonthYear(value.getFullYear(), displayMonth);\n                core_1.Utils.safeInvoke(_this.props.onChange, value, false);\n            }\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, value);\n            _this.setStateWithValueIfUncontrolled({ displayMonth: displayMonth }, value);\n        };\n        _this.handleYearSelectChange = function (displayYear) {\n            var _a = _this.state, displayMonth = _a.displayMonth, value = _a.value;\n            if (value !== null) {\n                value = _this.computeValidDateInSpecifiedMonthYear(displayYear, displayMonth);\n                core_1.Utils.safeInvoke(_this.props.onChange, value, false);\n                displayMonth = value.getMonth();\n            }\n            else {\n                var _b = _this.props, minDate = _b.minDate, maxDate = _b.maxDate;\n                var minYear = minDate.getFullYear();\n                var maxYear = maxDate.getFullYear();\n                var minMonth = minDate.getMonth();\n                var maxMonth = maxDate.getMonth();\n                if (displayYear === minYear && displayMonth < minMonth) {\n                    displayMonth = minMonth;\n                }\n                else if (displayYear === maxYear && displayMonth > maxMonth) {\n                    displayMonth = maxMonth;\n                }\n            }\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, value);\n            _this.setStateWithValueIfUncontrolled({ displayMonth: displayMonth, displayYear: displayYear }, value);\n        };\n        _this.handleClearClick = function () {\n            if (_this.props.value === undefined) {\n                _this.setState({ value: null });\n            }\n            core_1.Utils.safeInvoke(_this.props.onChange, null, true);\n        };\n        _this.handleTodayClick = function () {\n            var value = new Date();\n            var displayMonth = value.getMonth();\n            var displayYear = value.getFullYear();\n            var selectedDay = value.getDate();\n            if (_this.props.value === undefined) {\n                _this.setState({ displayMonth: displayMonth, displayYear: displayYear, selectedDay: selectedDay, value: value });\n            }\n            else {\n                _this.setState({ displayMonth: displayMonth, displayYear: displayYear, selectedDay: selectedDay });\n            }\n            core_1.Utils.safeInvoke(_this.props.onChange, value, true);\n        };\n        var value = null;\n        if (props.value !== undefined) {\n            value = props.value;\n        }\n        else if (props.defaultValue != null) {\n            value = props.defaultValue;\n        }\n        var selectedDay;\n        if (value !== null) {\n            selectedDay = value.getDate();\n        }\n        var initialMonth;\n        var today = new Date();\n        if (props.initialMonth != null) {\n            initialMonth = props.initialMonth;\n        }\n        else if (value != null) {\n            initialMonth = value;\n        }\n        else if (DateUtils.isDayInRange(today, [props.minDate, props.maxDate])) {\n            initialMonth = today;\n        }\n        else {\n            initialMonth = DateUtils.getDateBetween([props.minDate, props.maxDate]);\n        }\n        _this.state = {\n            displayMonth: initialMonth.getMonth(),\n            displayYear: initialMonth.getFullYear(),\n            selectedDay: selectedDay,\n            value: value,\n        };\n        return _this;\n    }\n    DatePicker.prototype.render = function () {\n        var _a = this.props, className = _a.className, dayPickerProps = _a.dayPickerProps, locale = _a.locale, localeUtils = _a.localeUtils, maxDate = _a.maxDate, minDate = _a.minDate, modifiers = _a.modifiers, showActionsBar = _a.showActionsBar;\n        var _b = this.state, displayMonth = _b.displayMonth, displayYear = _b.displayYear;\n        return (React.createElement(\"div\", { className: classNames(Classes.DATEPICKER, className) },\n            React.createElement(ReactDayPicker, tslib_1.__assign({ enableOutsideDays: true, locale: locale, localeUtils: localeUtils, modifiers: modifiers }, dayPickerProps, { canChangeMonth: true, captionElement: this.renderCaption, disabledDays: this.getDisabledDaysModifier(), fromMonth: minDate, month: new Date(displayYear, displayMonth), onDayClick: this.handleDayClick, onMonthChange: this.handleMonthChange, selectedDays: this.state.value, toMonth: maxDate })),\n            showActionsBar ? this.renderOptionsBar() : null));\n    };\n    DatePicker.prototype.componentWillReceiveProps = function (nextProps) {\n        if (nextProps.value !== this.props.value) {\n            var _a = this.state, displayMonth = _a.displayMonth, displayYear = _a.displayYear, selectedDay = _a.selectedDay;\n            if (nextProps.value != null) {\n                displayMonth = nextProps.value.getMonth();\n                displayYear = nextProps.value.getFullYear();\n                selectedDay = nextProps.value.getDate();\n            }\n            this.setState({\n                displayMonth: displayMonth,\n                displayYear: displayYear,\n                selectedDay: selectedDay,\n                value: nextProps.value,\n            });\n        }\n        _super.prototype.componentWillReceiveProps.call(this, nextProps);\n    };\n    DatePicker.prototype.validateProps = function (props) {\n        var defaultValue = props.defaultValue, initialMonth = props.initialMonth, maxDate = props.maxDate, minDate = props.minDate, value = props.value;\n        if (defaultValue != null && !DateUtils.isDayInRange(defaultValue, [minDate, maxDate])) {\n            throw new Error(Errors.DATEPICKER_DEFAULT_VALUE_INVALID);\n        }\n        if (initialMonth != null && !DateUtils.isMonthInRange(initialMonth, [minDate, maxDate])) {\n            throw new Error(Errors.DATEPICKER_INITIAL_MONTH_INVALID);\n        }\n        if (maxDate != null && minDate != null && maxDate < minDate && !DateUtils.areSameDay(maxDate, minDate)) {\n            throw new Error(Errors.DATEPICKER_MAX_DATE_INVALID);\n        }\n        if (value != null && !DateUtils.isDayInRange(value, [minDate, maxDate])) {\n            throw new Error(Errors.DATEPICKER_VALUE_INVALID);\n        }\n    };\n    DatePicker.prototype.renderOptionsBar = function () {\n        return (React.createElement(\"div\", { className: Classes.DATEPICKER_FOOTER },\n            React.createElement(core_1.Button, { className: \"pt-minimal pt-datepicker-footer-button\", onClick: this.handleTodayClick, text: \"Today\" }),\n            React.createElement(core_1.Button, { className: \"pt-minimal pt-datepicker-footer-button\", onClick: this.handleClearClick, text: \"Clear\" })));\n    };\n    DatePicker.prototype.computeValidDateInSpecifiedMonthYear = function (displayYear, displayMonth) {\n        var _a = this.props, minDate = _a.minDate, maxDate = _a.maxDate;\n        var maxDaysInMonth = new Date(displayYear, displayMonth + 1, 0).getDate();\n        var selectedDay = this.state.selectedDay;\n        if (selectedDay > maxDaysInMonth) {\n            selectedDay = maxDaysInMonth;\n        }\n        // matches the underlying react-day-picker timestamp behavior\n        var value = new Date(displayYear, displayMonth, selectedDay, 12);\n        if (value < minDate) {\n            value = minDate;\n        }\n        else if (value > maxDate) {\n            value = maxDate;\n        }\n        return value;\n    };\n    DatePicker.prototype.setStateWithValueIfUncontrolled = function (newState, value) {\n        if (this.props.value === undefined) {\n            // uncontrolled mode means we track value in state\n            newState.value = value;\n        }\n        return this.setState(newState);\n    };\n    return DatePicker;\n}(core_1.AbstractComponent));\nDatePicker.defaultProps = {\n    canClearSelection: true,\n    dayPickerProps: {},\n    maxDate: datePickerCore_1.getDefaultMaxDate(),\n    minDate: datePickerCore_1.getDefaultMinDate(),\n    showActionsBar: false,\n};\nDatePicker.displayName = \"Blueprint.DatePicker\";\nexports.DatePicker = DatePicker;\nexports.DatePickerFactory = React.createFactory(DatePicker);\n\n//# sourceMappingURL=datePicker.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/datePicker.js\n// module id = 11\n// module chunks = 0","/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar core_1 = require(\"@blueprintjs/core\");\nvar classNames = require(\"classnames\");\nvar React = require(\"react\");\nvar Classes = require(\"./common/classes\");\nvar Utils = require(\"./common/utils\");\nvar DatePickerCaption = (function (_super) {\n    tslib_1.__extends(DatePickerCaption, _super);\n    function DatePickerCaption() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.containerRefHandler = function (r) { return (_this.containerElement = r); };\n        _this.monthArrowRefHandler = function (r) { return (_this.monthArrowElement = r); };\n        _this.yearArrowRefHandler = function (r) { return (_this.yearArrowElement = r); };\n        _this.handleMonthSelectChange = function (e) {\n            var month = parseInt(e.target.value, 10);\n            core_1.Utils.safeInvoke(_this.props.onMonthChange, month);\n        };\n        _this.handleYearSelectChange = function (e) {\n            var year = parseInt(e.target.value, 10);\n            core_1.Utils.safeInvoke(_this.props.onYearChange, year);\n        };\n        return _this;\n    }\n    DatePickerCaption.prototype.render = function () {\n        var _a = this.props, date = _a.date, locale = _a.locale, localeUtils = _a.localeUtils, minDate = _a.minDate, maxDate = _a.maxDate;\n        var minYear = minDate.getFullYear();\n        var maxYear = maxDate.getFullYear();\n        var displayMonth = date.getMonth();\n        var displayYear = date.getFullYear();\n        // build the list of available months, limiting based on minDate and maxDate as necessary\n        var months = localeUtils.getMonths(locale);\n        var startMonth = displayYear === minYear ? minDate.getMonth() : 0;\n        var endMonth = displayYear === maxYear ? maxDate.getMonth() + 1 : undefined;\n        var monthOptionElements = months\n            .map(function (name, i) {\n            return (React.createElement(\"option\", { key: i, value: i.toString() }, name));\n        })\n            .slice(startMonth, endMonth);\n        var years = [minYear];\n        for (var year = minYear + 1; year <= maxYear; ++year) {\n            years.push(year);\n        }\n        var yearOptionElements = years.map(function (year, i) {\n            return (React.createElement(\"option\", { key: i, value: year.toString() }, year));\n        });\n        // allow out-of-bounds years but disable the option. this handles the Dec 2016 case in #391.\n        if (displayYear > maxYear) {\n            yearOptionElements.push(React.createElement(\"option\", { key: \"next\", disabled: true, value: displayYear.toString() }, displayYear));\n        }\n        this.displayedMonthText = months[displayMonth];\n        this.displayedYearText = displayYear.toString();\n        var caretClasses = classNames(\"pt-icon-standard\", \"pt-icon-caret-down\", Classes.DATEPICKER_CAPTION_CARET);\n        return (React.createElement(\"div\", { className: Classes.DATEPICKER_CAPTION, ref: this.containerRefHandler },\n            React.createElement(\"div\", { className: Classes.DATEPICKER_CAPTION_SELECT },\n                React.createElement(\"select\", { className: Classes.DATEPICKER_MONTH_SELECT, onChange: this.handleMonthSelectChange, value: displayMonth.toString() }, monthOptionElements),\n                React.createElement(\"span\", { className: caretClasses, ref: this.monthArrowRefHandler })),\n            React.createElement(\"div\", { className: Classes.DATEPICKER_CAPTION_SELECT },\n                React.createElement(\"select\", { className: Classes.DATEPICKER_YEAR_SELECT, onChange: this.handleYearSelectChange, value: displayYear.toString() }, yearOptionElements),\n                React.createElement(\"span\", { className: caretClasses, ref: this.yearArrowRefHandler }))));\n    };\n    DatePickerCaption.prototype.componentDidMount = function () {\n        this.positionArrows();\n    };\n    DatePickerCaption.prototype.componentDidUpdate = function () {\n        this.positionArrows();\n    };\n    DatePickerCaption.prototype.positionArrows = function () {\n        // pass our container element to the measureTextWidth utility to ensure\n        // that we're measuring the width of text as sized within this component.\n        var textClass = \"pt-datepicker-caption-measure\";\n        var monthWidth = Utils.measureTextWidth(this.displayedMonthText, textClass, this.containerElement);\n        this.monthArrowElement.setAttribute(\"style\", \"left:\" + monthWidth);\n        var yearWidth = Utils.measureTextWidth(this.displayedYearText, textClass, this.containerElement);\n        this.yearArrowElement.setAttribute(\"style\", \"left:\" + yearWidth);\n    };\n    return DatePickerCaption;\n}(React.Component));\nexports.DatePickerCaption = DatePickerCaption;\n\n//# sourceMappingURL=datePickerCaption.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/datePickerCaption.js\n// module id = 12\n// module chunks = 0","/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Measure width of a string displayed with styles provided by `className`.\n * Should only be used if measuring can't be done with existing DOM elements.\n */\nfunction measureTextWidth(text, className, containerElement) {\n    if (className === void 0) { className = \"\"; }\n    if (containerElement === void 0) { containerElement = document.body; }\n    var span = document.createElement(\"span\");\n    span.classList.add(className);\n    span.textContent = text;\n    containerElement.appendChild(span);\n    var spanWidth = span.offsetWidth;\n    span.remove();\n    return spanWidth + \"px\";\n}\nexports.measureTextWidth = measureTextWidth;\nfunction padWithZeroes(str, minLength) {\n    if (str.length < minLength) {\n        return \"\" + stringRepeat(\"0\", minLength - str.length) + str;\n    }\n    else {\n        return str;\n    }\n}\nexports.padWithZeroes = padWithZeroes;\nfunction stringRepeat(str, numTimes) {\n    return new Array(numTimes + 1).join(str);\n}\n\n//# sourceMappingURL=utils.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/common/utils.js\n// module id = 13\n// module chunks = 0","/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DISABLED_MODIFIER = \"disabled\";\nexports.HOVERED_RANGE_MODIFIER = \"hovered-range\";\nexports.OUTSIDE_MODIFIER = \"outside\";\nexports.SELECTED_MODIFIER = \"selected\";\nexports.SELECTED_RANGE_MODIFIER = \"selected-range\";\n// modifiers the user can't set because they are used by Blueprint or react-day-picker\nexports.DISALLOWED_MODIFIERS = [\n    exports.DISABLED_MODIFIER,\n    exports.HOVERED_RANGE_MODIFIER,\n    exports.OUTSIDE_MODIFIER,\n    exports.SELECTED_MODIFIER,\n    exports.SELECTED_RANGE_MODIFIER,\n];\nfunction getDefaultMaxDate() {\n    var date = new Date();\n    date.setFullYear(date.getFullYear());\n    date.setMonth(11 /* DECEMBER */, 31);\n    return date;\n}\nexports.getDefaultMaxDate = getDefaultMaxDate;\nfunction getDefaultMinDate() {\n    var date = new Date();\n    date.setFullYear(date.getFullYear() - 20);\n    date.setMonth(0 /* JANUARY */, 1);\n    return date;\n}\nexports.getDefaultMinDate = getDefaultMinDate;\nfunction combineModifiers(baseModifiers, userModifiers) {\n    var modifiers = baseModifiers;\n    if (userModifiers != null) {\n        modifiers = {};\n        for (var _i = 0, _a = Object.keys(userModifiers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            if (exports.DISALLOWED_MODIFIERS.indexOf(key) === -1) {\n                modifiers[key] = userModifiers[key];\n            }\n        }\n        for (var _b = 0, _c = Object.keys(baseModifiers); _b < _c.length; _b++) {\n            var key = _c[_b];\n            modifiers[key] = baseModifiers[key];\n        }\n    }\n    return modifiers;\n}\nexports.combineModifiers = combineModifiers;\n\n//# sourceMappingURL=datePickerCore.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/datePickerCore.js\n// module id = 14\n// module chunks = 0","/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar classNames = require(\"classnames\");\nvar React = require(\"react\");\nvar core_1 = require(\"@blueprintjs/core\");\nvar Classes = require(\"./common/classes\");\nvar DateUtils = require(\"./common/dateUtils\");\nvar datePicker_1 = require(\"./datePicker\");\nvar timePicker_1 = require(\"./timePicker\");\nvar DateTimePicker = (function (_super) {\n    tslib_1.__extends(DateTimePicker, _super);\n    function DateTimePicker(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.handleDateChange = function (dateValue, isUserChange) {\n            if (_this.props.value === undefined) {\n                _this.setState({ dateValue: dateValue });\n            }\n            var value = DateUtils.getDateTime(dateValue, _this.state.timeValue);\n            core_1.Utils.safeInvoke(_this.props.onChange, value, isUserChange);\n        };\n        _this.handleTimeChange = function (timeValue) {\n            if (_this.props.value === undefined) {\n                _this.setState({ timeValue: timeValue });\n            }\n            var value = DateUtils.getDateTime(_this.state.dateValue, timeValue);\n            core_1.Utils.safeInvoke(_this.props.onChange, value, true);\n        };\n        var initialValue = _this.props.value !== undefined ? _this.props.value : _this.props.defaultValue;\n        _this.state = {\n            dateValue: initialValue,\n            timeValue: initialValue,\n        };\n        return _this;\n    }\n    DateTimePicker.prototype.render = function () {\n        var value = DateUtils.getDateTime(this.state.dateValue, this.state.timeValue);\n        return (React.createElement(\"div\", { className: classNames(Classes.DATETIMEPICKER, this.props.className) },\n            React.createElement(datePicker_1.DatePicker, tslib_1.__assign({}, this.props.datePickerProps, { canClearSelection: this.props.canClearSelection, onChange: this.handleDateChange, value: value })),\n            React.createElement(timePicker_1.TimePicker, tslib_1.__assign({}, this.props.timePickerProps, { onChange: this.handleTimeChange, value: value }))));\n    };\n    DateTimePicker.prototype.componentWillReceiveProps = function (nextProps) {\n        if (this.props.value === nextProps.value) {\n            return;\n        }\n        else if (nextProps.value != null) {\n            this.setState({\n                dateValue: nextProps.value,\n                timeValue: nextProps.value,\n            });\n        }\n        else {\n            // clear only the date to remove the selected-date style in the calendar\n            this.setState({ dateValue: null });\n        }\n    };\n    return DateTimePicker;\n}(core_1.AbstractComponent));\nDateTimePicker.defaultProps = {\n    canClearSelection: true,\n    defaultValue: new Date(),\n};\nDateTimePicker.displayName = \"Blueprint.DateTimePicker\";\nexports.DateTimePicker = DateTimePicker;\n\n//# sourceMappingURL=dateTimePicker.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/dateTimePicker.js\n// module id = 15\n// module chunks = 0","/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar core_1 = require(\"@blueprintjs/core\");\nvar classNames = require(\"classnames\");\nvar React = require(\"react\");\nvar Classes = require(\"./common/classes\");\nvar DateUtils = require(\"./common/dateUtils\");\nvar Utils = require(\"./common/utils\");\nvar TimePickerPrecision;\n(function (TimePickerPrecision) {\n    TimePickerPrecision[TimePickerPrecision[\"MINUTE\"] = 0] = \"MINUTE\";\n    TimePickerPrecision[TimePickerPrecision[\"SECOND\"] = 1] = \"SECOND\";\n    TimePickerPrecision[TimePickerPrecision[\"MILLISECOND\"] = 2] = \"MILLISECOND\";\n})(TimePickerPrecision = exports.TimePickerPrecision || (exports.TimePickerPrecision = {}));\nvar DEFAULT_MIN_HOUR = 0;\nvar DEFAULT_MIN_MINUTE = 0;\nvar DEFAULT_MIN_SECOND = 0;\nvar DEFAULT_MIN_MILLISECOND = 0;\nvar DEFAULT_MAX_HOUR = 23;\nvar DEFAULT_MAX_MINUTE = 59;\nvar DEFAULT_MAX_SECOND = 59;\nvar DEFAULT_MAX_MILLISECOND = 999;\nfunction getDefaultMinTime() {\n    return new Date(0, 0, 0, DEFAULT_MIN_HOUR, DEFAULT_MIN_MINUTE, DEFAULT_MIN_SECOND, DEFAULT_MIN_MILLISECOND);\n}\nexports.getDefaultMinTime = getDefaultMinTime;\nfunction getDefaultMaxTime() {\n    return new Date(0, 0, 0, DEFAULT_MAX_HOUR, DEFAULT_MAX_MINUTE, DEFAULT_MAX_SECOND, DEFAULT_MAX_MILLISECOND);\n}\nexports.getDefaultMaxTime = getDefaultMaxTime;\nvar TimePicker = (function (_super) {\n    tslib_1.__extends(TimePicker, _super);\n    function TimePicker(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        // begin method definitions: event handlers\n        _this.getInputBlurHandler = function (unit) { return function (e) {\n            var text = getStringValueFromInputEvent(e);\n            _this.updateTime(parseInt(text, 10), unit);\n        }; };\n        _this.getInputChangeHandler = function (unit) { return function (e) {\n            var TWO_DIGITS = /^\\d{0,2}$/;\n            var THREE_DIGITS = /^\\d{0,3}$/;\n            var text = getStringValueFromInputEvent(e);\n            var isValid = false;\n            switch (unit) {\n                case TimeUnit.HOUR:\n                case TimeUnit.MINUTE:\n                case TimeUnit.SECOND:\n                    isValid = TWO_DIGITS.test(text);\n                    break;\n                case TimeUnit.MS:\n                    isValid = THREE_DIGITS.test(text);\n                    break;\n                default:\n                    throw Error(\"Invalid TimeUnit\");\n            }\n            if (isValid) {\n                switch (unit) {\n                    case TimeUnit.HOUR:\n                        _this.updateState({ hourText: text });\n                        break;\n                    case TimeUnit.MINUTE:\n                        _this.updateState({ minuteText: text });\n                        break;\n                    case TimeUnit.SECOND:\n                        _this.updateState({ secondText: text });\n                        break;\n                    case TimeUnit.MS:\n                        _this.updateState({ millisecondText: text });\n                        break;\n                    default:\n                        throw Error(\"Invalid TimeUnit\");\n                }\n            }\n        }; };\n        _this.getInputKeyDownHandler = function (unit) { return function (e) {\n            handleKeyEvent(e, (_a = {},\n                _a[core_1.Keys.ARROW_UP] = function () { return _this.incrementTime(unit); },\n                _a[core_1.Keys.ARROW_DOWN] = function () { return _this.decrementTime(unit); },\n                _a[core_1.Keys.ENTER] = function () {\n                    e.currentTarget.blur();\n                },\n                _a));\n            var _a;\n        }; };\n        _this.handleFocus = function (e) {\n            if (_this.props.selectAllOnFocus) {\n                e.currentTarget.select();\n            }\n        };\n        if (props.value != null) {\n            _this.state = _this.getFullStateFromValue(props.value);\n        }\n        else if (props.defaultValue != null) {\n            _this.state = _this.getFullStateFromValue(props.defaultValue);\n        }\n        else {\n            _this.state = _this.getFullStateFromValue(props.minTime);\n        }\n        return _this;\n    }\n    TimePicker.prototype.render = function () {\n        var _this = this;\n        var shouldRenderSeconds = this.props.precision >= TimePickerPrecision.SECOND;\n        var shouldRenderMilliseconds = this.props.precision >= TimePickerPrecision.MILLISECOND;\n        var classes = classNames(Classes.TIMEPICKER, this.props.className, (_a = {},\n            _a[core_1.Classes.DISABLED] = this.props.disabled,\n            _a));\n        /* tslint:disable:max-line-length */\n        return (React.createElement(\"div\", { className: classes },\n            React.createElement(\"div\", { className: Classes.TIMEPICKER_ARROW_ROW },\n                this.maybeRenderArrowButton(true, Classes.TIMEPICKER_HOUR, function () {\n                    return _this.incrementTime(TimeUnit.HOUR);\n                }),\n                this.maybeRenderArrowButton(true, Classes.TIMEPICKER_MINUTE, function () {\n                    return _this.incrementTime(TimeUnit.MINUTE);\n                }),\n                shouldRenderSeconds\n                    ? this.maybeRenderArrowButton(true, Classes.TIMEPICKER_SECOND, function () {\n                        return _this.incrementTime(TimeUnit.SECOND);\n                    })\n                    : null,\n                shouldRenderMilliseconds\n                    ? this.maybeRenderArrowButton(true, Classes.TIMEPICKER_MILLISECOND, function () {\n                        return _this.incrementTime(TimeUnit.MS);\n                    })\n                    : null),\n            React.createElement(\"div\", { className: Classes.TIMEPICKER_INPUT_ROW },\n                this.renderInput(Classes.TIMEPICKER_HOUR, TimeUnit.HOUR, this.state.hourText),\n                this.renderDivider(),\n                this.renderInput(Classes.TIMEPICKER_MINUTE, TimeUnit.MINUTE, this.state.minuteText),\n                shouldRenderSeconds ? this.renderDivider() : null,\n                shouldRenderSeconds\n                    ? this.renderInput(Classes.TIMEPICKER_SECOND, TimeUnit.SECOND, this.state.secondText)\n                    : null,\n                shouldRenderMilliseconds ? this.renderDivider(\".\") : null,\n                shouldRenderMilliseconds\n                    ? this.renderInput(Classes.TIMEPICKER_MILLISECOND, TimeUnit.MS, this.state.millisecondText)\n                    : null),\n            React.createElement(\"div\", { className: Classes.TIMEPICKER_ARROW_ROW },\n                this.maybeRenderArrowButton(false, Classes.TIMEPICKER_HOUR, function () {\n                    return _this.decrementTime(TimeUnit.HOUR);\n                }),\n                this.maybeRenderArrowButton(false, Classes.TIMEPICKER_MINUTE, function () {\n                    return _this.decrementTime(TimeUnit.MINUTE);\n                }),\n                shouldRenderSeconds\n                    ? this.maybeRenderArrowButton(false, Classes.TIMEPICKER_SECOND, function () {\n                        return _this.decrementTime(TimeUnit.SECOND);\n                    })\n                    : null,\n                shouldRenderMilliseconds\n                    ? this.maybeRenderArrowButton(false, Classes.TIMEPICKER_MILLISECOND, function () {\n                        return _this.decrementTime(TimeUnit.MS);\n                    })\n                    : null)));\n        var _a;\n        /* tslint:enable:max-line-length */\n    };\n    TimePicker.prototype.componentWillReceiveProps = function (nextProps) {\n        var didMinTimeChange = nextProps.minTime !== this.props.minTime;\n        var didMaxTimeChange = nextProps.maxTime !== this.props.maxTime;\n        var didBoundsChange = didMinTimeChange || didMaxTimeChange;\n        if (didBoundsChange) {\n            var timeInRange = DateUtils.getTimeInRange(this.state.value, nextProps.minTime, nextProps.maxTime);\n            this.setState(this.getFullStateFromValue(timeInRange));\n        }\n        if (nextProps.value != null && !DateUtils.areSameTime(nextProps.value, this.props.value)) {\n            this.setState(this.getFullStateFromValue(nextProps.value));\n        }\n    };\n    // begin method definitions: rendering\n    TimePicker.prototype.maybeRenderArrowButton = function (isDirectionUp, className, onClick) {\n        var classes = classNames(Classes.TIMEPICKER_ARROW_BUTTON, className, \"pt-icon-standard\", {\n            \"pt-icon-chevron-down\": !isDirectionUp,\n            \"pt-icon-chevron-up\": isDirectionUp,\n        });\n        return this.props.showArrowButtons ? React.createElement(\"span\", { className: classes, onClick: onClick }) : null;\n    };\n    TimePicker.prototype.renderDivider = function (text) {\n        if (text === void 0) { text = \":\"; }\n        return React.createElement(\"span\", { className: Classes.TIMEPICKER_DIVIDER_TEXT }, text);\n    };\n    TimePicker.prototype.renderInput = function (className, unit, value) {\n        return (React.createElement(\"input\", { className: classNames(Classes.TIMEPICKER_INPUT, className), onBlur: this.getInputBlurHandler(unit), onChange: this.getInputChangeHandler(unit), onFocus: this.handleFocus, onKeyDown: this.getInputKeyDownHandler(unit), value: value, disabled: this.props.disabled }));\n    };\n    // begin method definitions: state modification\n    /**\n     * Generates a full ITimePickerState object with all text fields set to formatted strings based on value\n     */\n    TimePicker.prototype.getFullStateFromValue = function (value) {\n        var timeInRange = DateUtils.getTimeInRange(value, this.props.minTime, this.props.maxTime);\n        /* tslint:disable:object-literal-sort-keys */\n        return {\n            hourText: formatTime(timeInRange.getHours(), TimeUnit.HOUR),\n            minuteText: formatTime(timeInRange.getMinutes(), TimeUnit.MINUTE),\n            secondText: formatTime(timeInRange.getSeconds(), TimeUnit.SECOND),\n            millisecondText: formatTime(timeInRange.getMilliseconds(), TimeUnit.MS),\n            value: timeInRange,\n        };\n        /* tslint:enable:object-literal-sort-keys */\n    };\n    TimePicker.prototype.incrementTime = function (unit) {\n        if (this.props.disabled) {\n            return;\n        }\n        var newTime = getTimeUnit(this.state.value, unit) + 1;\n        this.updateTime(loopTime(newTime, unit), unit);\n    };\n    TimePicker.prototype.decrementTime = function (unit) {\n        if (this.props.disabled) {\n            return;\n        }\n        var newTime = getTimeUnit(this.state.value, unit) - 1;\n        this.updateTime(loopTime(newTime, unit), unit);\n    };\n    TimePicker.prototype.updateTime = function (time, unit) {\n        var newValue = DateUtils.clone(this.state.value);\n        if (isTimeValid(time, unit)) {\n            setTimeUnit(time, newValue, unit);\n            if (DateUtils.isTimeInRange(newValue, this.props.minTime, this.props.maxTime)) {\n                this.updateState({ value: newValue });\n            }\n            else if (!DateUtils.areSameTime(this.state.value, this.props.minTime)) {\n                this.updateState(this.getFullStateFromValue(newValue));\n            }\n        }\n        else {\n            // reset to last known good state\n            this.updateState(this.getFullStateFromValue(this.state.value));\n        }\n    };\n    TimePicker.prototype.updateState = function (state) {\n        var newState = state;\n        var hasNewValue = newState.value != null && !DateUtils.areSameTime(newState.value, this.state.value);\n        if (this.props.value == null) {\n            // component is uncontrolled\n            if (hasNewValue) {\n                newState = this.getFullStateFromValue(newState.value);\n            }\n            this.setState(newState);\n        }\n        else {\n            // component is controlled, and there's a new value\n            // so set inputs' text based off of _old_ value and later fire onChange with new value\n            if (hasNewValue) {\n                this.setState(this.getFullStateFromValue(this.state.value));\n            }\n            else {\n                // no new value, this means only text has changed (from user typing)\n                // we want inputs to change, so update state with new text for the inputs\n                // but don't change actual value\n                this.setState(tslib_1.__assign({}, newState, { value: DateUtils.clone(this.state.value) }));\n            }\n        }\n        if (hasNewValue) {\n            core_1.Utils.safeInvoke(this.props.onChange, newState.value);\n        }\n    };\n    return TimePicker;\n}(React.Component));\nTimePicker.defaultProps = {\n    disabled: false,\n    maxTime: getDefaultMaxTime(),\n    minTime: getDefaultMinTime(),\n    precision: TimePickerPrecision.MINUTE,\n    selectAllOnFocus: false,\n    showArrowButtons: false,\n};\nTimePicker.displayName = \"Blueprint.TimePicker\";\nexports.TimePicker = TimePicker;\nvar TimeUnit;\n(function (TimeUnit) {\n    TimeUnit[TimeUnit[\"HOUR\"] = 0] = \"HOUR\";\n    TimeUnit[TimeUnit[\"MINUTE\"] = 1] = \"MINUTE\";\n    TimeUnit[TimeUnit[\"SECOND\"] = 2] = \"SECOND\";\n    TimeUnit[TimeUnit[\"MS\"] = 3] = \"MS\";\n})(TimeUnit || (TimeUnit = {}));\nfunction formatTime(time, unit) {\n    switch (unit) {\n        case TimeUnit.HOUR:\n            return time.toString();\n        case TimeUnit.MINUTE:\n        case TimeUnit.SECOND:\n            return Utils.padWithZeroes(time.toString(), 2);\n        case TimeUnit.MS:\n            return Utils.padWithZeroes(time.toString(), 3);\n        default:\n            throw Error(\"Invalid TimeUnit\");\n    }\n}\nfunction getStringValueFromInputEvent(e) {\n    return e.currentTarget.value;\n}\nfunction getTimeUnit(date, unit) {\n    switch (unit) {\n        case TimeUnit.HOUR:\n            return date.getHours();\n        case TimeUnit.MINUTE:\n            return date.getMinutes();\n        case TimeUnit.SECOND:\n            return date.getSeconds();\n        case TimeUnit.MS:\n            return date.getMilliseconds();\n        default:\n            throw Error(\"Invalid TimeUnit\");\n    }\n}\nfunction handleKeyEvent(e, actions, preventDefault) {\n    if (preventDefault === void 0) { preventDefault = true; }\n    for (var _i = 0, _a = Object.keys(actions); _i < _a.length; _i++) {\n        var k = _a[_i];\n        var key = Number(k);\n        if (e.which === key) {\n            if (preventDefault) {\n                e.preventDefault();\n            }\n            actions[key]();\n        }\n    }\n}\nfunction isTimeValid(time, unit) {\n    return time != null && !isNaN(time) && minTime(unit) <= time && time <= maxTime(unit);\n}\nfunction loopTime(time, unit) {\n    var max = maxTime(unit);\n    var min = minTime(unit);\n    if (time > max) {\n        return min;\n    }\n    else if (time < min) {\n        return max;\n    }\n    return time;\n}\nfunction minTime(unit) {\n    var min = (_a = {},\n        _a[TimeUnit.HOUR] = DEFAULT_MIN_HOUR,\n        _a[TimeUnit.MINUTE] = DEFAULT_MIN_MINUTE,\n        _a[TimeUnit.SECOND] = DEFAULT_MIN_SECOND,\n        _a[TimeUnit.MS] = DEFAULT_MIN_MILLISECOND,\n        _a);\n    return min[unit];\n    var _a;\n}\nfunction maxTime(unit) {\n    var max = (_a = {},\n        _a[TimeUnit.HOUR] = DEFAULT_MAX_HOUR,\n        _a[TimeUnit.MINUTE] = DEFAULT_MAX_MINUTE,\n        _a[TimeUnit.SECOND] = DEFAULT_MAX_SECOND,\n        _a[TimeUnit.MS] = DEFAULT_MAX_MILLISECOND,\n        _a);\n    return max[unit];\n    var _a;\n}\nfunction setTimeUnit(time, date, unit) {\n    switch (unit) {\n        case TimeUnit.HOUR:\n            date.setHours(time);\n            break;\n        case TimeUnit.MINUTE:\n            date.setMinutes(time);\n            break;\n        case TimeUnit.SECOND:\n            date.setSeconds(time);\n            break;\n        case TimeUnit.MS:\n            date.setMilliseconds(time);\n            break;\n        default:\n            throw Error(\"Invalid TimeUnit\");\n    }\n}\nexports.TimePickerFactory = React.createFactory(TimePicker);\n\n//# sourceMappingURL=timePicker.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/timePicker.js\n// module id = 16\n// module chunks = 0","/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar classNames = require(\"classnames\");\nvar moment = require(\"moment\");\nvar React = require(\"react\");\nvar core_1 = require(\"@blueprintjs/core\");\nvar dateUtils_1 = require(\"./common/dateUtils\");\nvar Errors = require(\"./common/errors\");\nvar datePickerCore_1 = require(\"./datePickerCore\");\nvar dateRangePicker_1 = require(\"./dateRangePicker\");\nvar DateRangeInput = (function (_super) {\n    tslib_1.__extends(DateRangeInput, _super);\n    function DateRangeInput(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.refHandlers = {\n            endInputRef: function (ref) {\n                _this.endInputRef = ref;\n                core_1.Utils.safeInvoke(_this.props.endInputProps.inputRef, ref);\n            },\n            startInputRef: function (ref) {\n                _this.startInputRef = ref;\n                core_1.Utils.safeInvoke(_this.props.startInputProps.inputRef, ref);\n            },\n        };\n        _this.renderInputGroup = function (boundary) {\n            var inputProps = _this.getInputProps(boundary);\n            // don't include `ref` in the returned HTML props, because passing it to the InputGroup\n            // leads to TS typing errors.\n            var ref = inputProps.ref, htmlProps = tslib_1.__rest(inputProps, [\"ref\"]);\n            var handleInputEvent = boundary === dateUtils_1.DateRangeBoundary.START ? _this.handleStartInputEvent : _this.handleEndInputEvent;\n            var classes = classNames((_a = {},\n                _a[core_1.Classes.INTENT_DANGER] = _this.isInputInErrorState(boundary),\n                _a), inputProps.className);\n            return (React.createElement(core_1.InputGroup, tslib_1.__assign({ autoComplete: \"off\" }, htmlProps, { className: classes, disabled: _this.props.disabled, inputRef: _this.getInputRef(boundary), onBlur: handleInputEvent, onChange: handleInputEvent, onClick: handleInputEvent, onFocus: handleInputEvent, onKeyDown: handleInputEvent, onMouseDown: handleInputEvent, placeholder: _this.getInputPlaceholderString(boundary), value: _this.getInputDisplayString(boundary) })));\n            var _a;\n        };\n        // Callbacks - DateRangePicker\n        // ===========================\n        _this.handleDateRangePickerChange = function (selectedRange) {\n            // ignore mouse events in the date-range picker if the popover is animating closed.\n            if (!_this.state.isOpen) {\n                return;\n            }\n            var _a = dateUtils_1.fromDateRangeToMomentDateRange(selectedRange), selectedStart = _a[0], selectedEnd = _a[1];\n            var isOpen = true;\n            var isStartInputFocused;\n            var isEndInputFocused;\n            var startHoverString;\n            var endHoverString;\n            if (dateUtils_1.isMomentNull(selectedStart)) {\n                // focus the start field by default or if only an end date is specified\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n                // for clarity, hide the hover string until the mouse moves over a different date\n                startHoverString = null;\n            }\n            else if (dateUtils_1.isMomentNull(selectedEnd)) {\n                // focus the end field if a start date is specified\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n                endHoverString = null;\n            }\n            else if (_this.props.closeOnSelection) {\n                isOpen = false;\n                isStartInputFocused = false;\n                isEndInputFocused = false;\n            }\n            else if (_this.state.lastFocusedField === dateUtils_1.DateRangeBoundary.START) {\n                // keep the start field focused\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n            }\n            else {\n                // keep the end field focused\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n            }\n            var baseStateChange = {\n                endHoverString: endHoverString,\n                endInputString: _this.getFormattedDateString(selectedEnd),\n                isEndInputFocused: isEndInputFocused,\n                isOpen: isOpen,\n                isStartInputFocused: isStartInputFocused,\n                startHoverString: startHoverString,\n                startInputString: _this.getFormattedDateString(selectedStart),\n                wasLastFocusChangeDueToHover: false,\n            };\n            if (_this.isControlled()) {\n                _this.setState(baseStateChange);\n            }\n            else {\n                _this.setState(tslib_1.__assign({}, baseStateChange, { selectedEnd: selectedEnd, selectedStart: selectedStart }));\n            }\n            core_1.Utils.safeInvoke(_this.props.onChange, selectedRange);\n        };\n        _this.handleDateRangePickerHoverChange = function (hoveredRange, _hoveredDay, hoveredBoundary) {\n            // ignore mouse events in the date-range picker if the popover is animating closed.\n            if (!_this.state.isOpen) {\n                return;\n            }\n            if (hoveredRange == null) {\n                // undo whatever focus changes we made while hovering over various calendar dates\n                var isEndInputFocused = _this.state.boundaryToModify === dateUtils_1.DateRangeBoundary.END;\n                _this.setState({\n                    endHoverString: null,\n                    isEndInputFocused: isEndInputFocused,\n                    isStartInputFocused: !isEndInputFocused,\n                    lastFocusedField: _this.state.boundaryToModify,\n                    startHoverString: null,\n                });\n            }\n            else {\n                var _a = dateUtils_1.fromDateRangeToMomentDateRange(hoveredRange), hoveredStart = _a[0], hoveredEnd = _a[1];\n                var isStartInputFocused = hoveredBoundary != null ? hoveredBoundary === dateUtils_1.DateRangeBoundary.START : _this.state.isStartInputFocused;\n                var isEndInputFocused = hoveredBoundary != null ? hoveredBoundary === dateUtils_1.DateRangeBoundary.END : _this.state.isEndInputFocused;\n                _this.setState({\n                    endHoverString: _this.getFormattedDateString(hoveredEnd),\n                    isEndInputFocused: isEndInputFocused,\n                    isStartInputFocused: isStartInputFocused,\n                    lastFocusedField: isStartInputFocused ? dateUtils_1.DateRangeBoundary.START : dateUtils_1.DateRangeBoundary.END,\n                    shouldSelectAfterUpdate: _this.props.selectAllOnFocus,\n                    startHoverString: _this.getFormattedDateString(hoveredStart),\n                    wasLastFocusChangeDueToHover: true,\n                });\n            }\n        };\n        // Callbacks - Input\n        // =================\n        // instantiate these two functions once so we don't have to for each callback on each render.\n        _this.handleStartInputEvent = function (e) {\n            _this.handleInputEvent(e, dateUtils_1.DateRangeBoundary.START);\n        };\n        _this.handleEndInputEvent = function (e) {\n            _this.handleInputEvent(e, dateUtils_1.DateRangeBoundary.END);\n        };\n        _this.handleInputEvent = function (e, boundary) {\n            switch (e.type) {\n                case \"blur\":\n                    _this.handleInputBlur(e, boundary);\n                    break;\n                case \"change\":\n                    _this.handleInputChange(e, boundary);\n                    break;\n                case \"click\":\n                    _this.handleInputClick(e);\n                    break;\n                case \"focus\":\n                    _this.handleInputFocus(e, boundary);\n                    break;\n                case \"keydown\":\n                    _this.handleInputKeyDown(e);\n                    break;\n                case \"mousedown\":\n                    _this.handleInputMouseDown();\n                    break;\n                default:\n                    break;\n            }\n            var inputProps = _this.getInputProps(boundary);\n            var callbackFn = _this.getInputGroupCallbackForEvent(e, inputProps);\n            core_1.Utils.safeInvoke(callbackFn, e);\n        };\n        // add a keydown listener to persistently change focus when tabbing:\n        // - if focused in start field, Tab moves focus to end field\n        // - if focused in end field, Shift+Tab moves focus to start field\n        _this.handleInputKeyDown = function (e) {\n            var isTabPressed = e.keyCode === core_1.Keys.TAB;\n            var isShiftPressed = e.shiftKey;\n            // order of JS events is our enemy here. when tabbing between fields,\n            // this handler will fire in the middle of a focus exchange when no\n            // field is currently focused. we work around this by referring to the\n            // most recently focused field, rather than the currently focused field.\n            var wasStartFieldFocused = _this.state.lastFocusedField === dateUtils_1.DateRangeBoundary.START;\n            var wasEndFieldFocused = _this.state.lastFocusedField === dateUtils_1.DateRangeBoundary.END;\n            var isEndInputFocused;\n            var isStartInputFocused;\n            // move focus to the other field\n            if (wasStartFieldFocused && isTabPressed && !isShiftPressed) {\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n            }\n            else if (wasEndFieldFocused && isTabPressed && isShiftPressed) {\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n            }\n            else {\n                // let the default keystroke happen without side effects\n                return;\n            }\n            // prevent the default focus-change behavior to avoid race conditions;\n            // we'll handle the focus change ourselves in componentDidUpdate.\n            e.preventDefault();\n            _this.setState({\n                isEndInputFocused: isEndInputFocused,\n                isStartInputFocused: isStartInputFocused,\n                wasLastFocusChangeDueToHover: false,\n            });\n        };\n        _this.handleInputMouseDown = function () {\n            // clicking in the field constitutes an explicit focus change. we update\n            // the flag on \"mousedown\" instead of on \"click\", because it needs to be\n            // set before onFocus is called (\"click\" triggers after \"focus\").\n            _this.setState({ wasLastFocusChangeDueToHover: false });\n        };\n        _this.handleInputClick = function (e) {\n            // unless we stop propagation on this event, a click within an input\n            // will close the popover almost as soon as it opens.\n            e.stopPropagation();\n        };\n        _this.handleInputFocus = function (_e, boundary) {\n            var _a = _this.getStateKeysAndValuesForBoundary(boundary), keys = _a.keys, values = _a.values;\n            var inputString = _this.getFormattedDateString(values.selectedValue);\n            // change the boundary only if the user explicitly focused in the field.\n            // focus changes from hovering don't count; they're just temporary.\n            var boundaryToModify = _this.state.wasLastFocusChangeDueToHover ? _this.state.boundaryToModify : boundary;\n            _this.setState((_b = {},\n                _b[keys.inputString] = inputString,\n                _b[keys.isInputFocused] = true,\n                _b.boundaryToModify = boundaryToModify,\n                _b.isOpen = true,\n                _b.lastFocusedField = boundary,\n                _b.shouldSelectAfterUpdate = _this.props.selectAllOnFocus,\n                _b.wasLastFocusChangeDueToHover = false,\n                _b));\n            var _b;\n        };\n        _this.handleInputBlur = function (_e, boundary) {\n            var _a = _this.getStateKeysAndValuesForBoundary(boundary), keys = _a.keys, values = _a.values;\n            var maybeNextValue = _this.dateStringToMoment(values.inputString);\n            var isValueControlled = _this.isControlled();\n            var nextState = (_b = {},\n                _b[keys.isInputFocused] = false,\n                _b.shouldSelectAfterUpdate = false,\n                _b);\n            if (_this.isInputEmpty(values.inputString)) {\n                if (isValueControlled) {\n                    nextState = tslib_1.__assign({}, nextState, (_c = {}, _c[keys.inputString] = _this.getFormattedDateString(values.controlledValue), _c));\n                }\n                else {\n                    nextState = tslib_1.__assign({}, nextState, (_d = {}, _d[keys.inputString] = null, _d[keys.selectedValue] = moment(null), _d));\n                }\n            }\n            else if (!_this.isNextDateRangeValid(maybeNextValue, boundary)) {\n                if (!isValueControlled) {\n                    nextState = tslib_1.__assign({}, nextState, (_f = {}, _f[keys.inputString] = null, _f[keys.selectedValue] = maybeNextValue, _f));\n                }\n                core_1.Utils.safeInvoke(_this.props.onError, _this.getDateRangeForCallback(maybeNextValue, boundary));\n            }\n            _this.setState(nextState);\n            var _b, _c, _d, _f;\n        };\n        _this.handleInputChange = function (e, boundary) {\n            var inputString = e.target.value;\n            var keys = _this.getStateKeysAndValuesForBoundary(boundary).keys;\n            var maybeNextValue = _this.dateStringToMoment(inputString);\n            var isValueControlled = _this.isControlled();\n            var nextState = { shouldSelectAfterUpdate: false };\n            if (inputString.length === 0) {\n                // this case will be relevant when we start showing the hovered range in the input\n                // fields. goal is to show an empty field for clarity until the mouse moves over a\n                // different date.\n                var baseState = tslib_1.__assign({}, nextState, (_a = {}, _a[keys.inputString] = \"\", _a));\n                if (isValueControlled) {\n                    nextState = baseState;\n                }\n                else {\n                    nextState = tslib_1.__assign({}, baseState, (_b = {}, _b[keys.selectedValue] = moment(null), _b));\n                }\n                core_1.Utils.safeInvoke(_this.props.onChange, _this.getDateRangeForCallback(moment(null), boundary));\n            }\n            else if (_this.isMomentValidAndInRange(maybeNextValue)) {\n                // note that error cases that depend on both fields (e.g. overlapping dates) should fall\n                // through into this block so that the UI can update immediately, possibly with an error\n                // message on the other field.\n                // also, clear the hover string to ensure the most recent keystroke appears.\n                var baseState = tslib_1.__assign({}, nextState, (_c = {}, _c[keys.hoverString] = null, _c[keys.inputString] = inputString, _c));\n                if (isValueControlled) {\n                    nextState = baseState;\n                }\n                else {\n                    nextState = tslib_1.__assign({}, baseState, (_d = {}, _d[keys.selectedValue] = maybeNextValue, _d));\n                }\n                if (_this.isNextDateRangeValid(maybeNextValue, boundary)) {\n                    core_1.Utils.safeInvoke(_this.props.onChange, _this.getDateRangeForCallback(maybeNextValue, boundary));\n                }\n            }\n            else {\n                // again, clear the hover string to ensure the most recent keystroke appears\n                nextState = tslib_1.__assign({}, nextState, (_f = {}, _f[keys.inputString] = inputString, _f[keys.hoverString] = null, _f));\n            }\n            _this.setState(nextState);\n            var _a, _b, _c, _d, _f;\n        };\n        // Callbacks - Popover\n        // ===================\n        _this.handlePopoverClose = function () {\n            _this.setState({ isOpen: false });\n            core_1.Utils.safeInvoke(_this.props.popoverProps.onClose);\n        };\n        _this.dateStringToMoment = function (dateString) {\n            if (_this.isInputEmpty(dateString)) {\n                return moment(null);\n            }\n            return moment(dateString, _this.props.format, _this.props.locale);\n        };\n        _this.getInitialRange = function (props) {\n            if (props === void 0) { props = _this.props; }\n            var defaultValue = props.defaultValue, value = props.value;\n            if (value != null) {\n                return dateUtils_1.fromDateRangeToMomentDateRange(value);\n            }\n            else if (defaultValue != null) {\n                return dateUtils_1.fromDateRangeToMomentDateRange(defaultValue);\n            }\n            else {\n                return [moment(null), moment(null)];\n            }\n        };\n        _this.getSelectedRange = function () {\n            var selectedStart;\n            var selectedEnd;\n            if (_this.isControlled()) {\n                _a = _this.props.value.map(dateUtils_1.fromDateToMoment), selectedStart = _a[0], selectedEnd = _a[1];\n            }\n            else {\n                selectedStart = _this.state.selectedStart;\n                selectedEnd = _this.state.selectedEnd;\n            }\n            // this helper function checks if the provided boundary date *would* overlap the selected\n            // other boundary date. providing the already-selected start date simply tells us if we're\n            // currently in an overlapping state.\n            var doBoundaryDatesOverlap = _this.doBoundaryDatesOverlap(selectedStart, dateUtils_1.DateRangeBoundary.START);\n            var momentDateRange = [selectedStart, doBoundaryDatesOverlap ? moment(null) : selectedEnd];\n            return momentDateRange.map(function (selectedBound) {\n                return _this.isMomentValidAndInRange(selectedBound) ? dateUtils_1.fromMomentToDate(selectedBound) : undefined;\n            });\n            var _a;\n        };\n        _this.getInputGroupCallbackForEvent = function (e, inputProps) {\n            // use explicit switch cases to ensure callback function names remain grep-able in the codebase.\n            switch (e.type) {\n                case \"blur\":\n                    return inputProps.onBlur;\n                case \"change\":\n                    return inputProps.onChange;\n                case \"click\":\n                    return inputProps.onClick;\n                case \"focus\":\n                    return inputProps.onFocus;\n                case \"keydown\":\n                    return inputProps.onKeyDown;\n                case \"mousedown\":\n                    return inputProps.onMouseDown;\n                default:\n                    return undefined;\n            }\n        };\n        _this.getInputDisplayString = function (boundary) {\n            var values = _this.getStateKeysAndValuesForBoundary(boundary).values;\n            var isInputFocused = values.isInputFocused, inputString = values.inputString, selectedValue = values.selectedValue, hoverString = values.hoverString;\n            if (hoverString != null) {\n                return hoverString;\n            }\n            else if (isInputFocused) {\n                return inputString == null ? \"\" : inputString;\n            }\n            else if (dateUtils_1.isMomentNull(selectedValue)) {\n                return \"\";\n            }\n            else if (!_this.isMomentInRange(selectedValue)) {\n                return _this.props.outOfRangeMessage;\n            }\n            else if (_this.doesEndBoundaryOverlapStartBoundary(selectedValue, boundary)) {\n                return _this.props.overlappingDatesMessage;\n            }\n            else {\n                return _this.getFormattedDateString(selectedValue);\n            }\n        };\n        _this.getInputPlaceholderString = function (boundary) {\n            var isStartBoundary = boundary === dateUtils_1.DateRangeBoundary.START;\n            var isEndBoundary = boundary === dateUtils_1.DateRangeBoundary.END;\n            var inputProps = _this.getInputProps(boundary);\n            var isInputFocused = _this.getStateKeysAndValuesForBoundary(boundary).values.isInputFocused;\n            // use the custom placeholder text for the input, if providied\n            if (inputProps.placeholder != null) {\n                return inputProps.placeholder;\n            }\n            else if (isStartBoundary) {\n                return isInputFocused ? _this.state.formattedMinDateString : \"Start date\";\n            }\n            else if (isEndBoundary) {\n                return isInputFocused ? _this.state.formattedMaxDateString : \"End date\";\n            }\n            else {\n                return \"\";\n            }\n        };\n        _this.getInputProps = function (boundary) {\n            return boundary === dateUtils_1.DateRangeBoundary.START ? _this.props.startInputProps : _this.props.endInputProps;\n        };\n        _this.getInputRef = function (boundary) {\n            return boundary === dateUtils_1.DateRangeBoundary.START ? _this.refHandlers.startInputRef : _this.refHandlers.endInputRef;\n        };\n        _this.getFormattedDateString = function (momentDate, formatOverride) {\n            if (dateUtils_1.isMomentNull(momentDate)) {\n                return \"\";\n            }\n            else if (!momentDate.isValid()) {\n                return _this.props.invalidDateMessage;\n            }\n            else {\n                var format = formatOverride != null ? formatOverride : _this.props.format;\n                return dateUtils_1.toLocalizedDateString(momentDate, format, _this.props.locale);\n            }\n        };\n        _this.getStateKeysAndValuesForBoundary = function (boundary) {\n            var controlledRange = dateUtils_1.fromDateRangeToMomentDateRange(_this.props.value);\n            if (boundary === dateUtils_1.DateRangeBoundary.START) {\n                return {\n                    keys: {\n                        hoverString: \"startHoverString\",\n                        inputString: \"startInputString\",\n                        isInputFocused: \"isStartInputFocused\",\n                        selectedValue: \"selectedStart\",\n                    },\n                    values: {\n                        controlledValue: controlledRange != null ? controlledRange[0] : undefined,\n                        hoverString: _this.state.startHoverString,\n                        inputString: _this.state.startInputString,\n                        isInputFocused: _this.state.isStartInputFocused,\n                        selectedValue: _this.state.selectedStart,\n                    },\n                };\n            }\n            else {\n                return {\n                    keys: {\n                        hoverString: \"endHoverString\",\n                        inputString: \"endInputString\",\n                        isInputFocused: \"isEndInputFocused\",\n                        selectedValue: \"selectedEnd\",\n                    },\n                    values: {\n                        controlledValue: controlledRange != null ? controlledRange[1] : undefined,\n                        hoverString: _this.state.endHoverString,\n                        inputString: _this.state.endInputString,\n                        isInputFocused: _this.state.isEndInputFocused,\n                        selectedValue: _this.state.selectedEnd,\n                    },\n                };\n            }\n        };\n        _this.getDateRangeForCallback = function (currValue, currBoundary) {\n            var otherBoundary = _this.getOtherBoundary(currBoundary);\n            var otherValue = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n            var currDate = _this.getDateForCallback(currValue);\n            var otherDate = _this.getDateForCallback(otherValue);\n            return currBoundary === dateUtils_1.DateRangeBoundary.START ? [currDate, otherDate] : [otherDate, currDate];\n        };\n        _this.getDateForCallback = function (momentDate) {\n            if (dateUtils_1.isMomentNull(momentDate)) {\n                return null;\n            }\n            else if (!momentDate.isValid()) {\n                return new Date(undefined);\n            }\n            else {\n                return dateUtils_1.fromMomentToDate(momentDate);\n            }\n        };\n        _this.getOtherBoundary = function (boundary) {\n            return boundary === dateUtils_1.DateRangeBoundary.START ? dateUtils_1.DateRangeBoundary.END : dateUtils_1.DateRangeBoundary.START;\n        };\n        _this.doBoundaryDatesOverlap = function (boundaryDate, boundary) {\n            var allowSingleDayRange = _this.props.allowSingleDayRange;\n            var otherBoundary = _this.getOtherBoundary(boundary);\n            var otherBoundaryDate = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n            if (boundary === dateUtils_1.DateRangeBoundary.START) {\n                return allowSingleDayRange\n                    ? boundaryDate.isAfter(otherBoundaryDate, \"day\")\n                    : boundaryDate.isSameOrAfter(otherBoundaryDate, \"day\");\n            }\n            else {\n                return allowSingleDayRange\n                    ? boundaryDate.isBefore(otherBoundaryDate, \"day\")\n                    : boundaryDate.isSameOrBefore(otherBoundaryDate, \"day\");\n            }\n        };\n        /**\n         * Returns true if the provided boundary is an END boundary overlapping the\n         * selected start date. (If the boundaries overlap, we consider the END\n         * boundary to be erroneous.)\n         */\n        _this.doesEndBoundaryOverlapStartBoundary = function (boundaryDate, boundary) {\n            return boundary === dateUtils_1.DateRangeBoundary.START ? false : _this.doBoundaryDatesOverlap(boundaryDate, boundary);\n        };\n        _this.isControlled = function () {\n            return _this.props.value !== undefined;\n        };\n        _this.isInputEmpty = function (inputString) {\n            return inputString == null || inputString.length === 0;\n        };\n        _this.isInputInErrorState = function (boundary) {\n            var values = _this.getStateKeysAndValuesForBoundary(boundary).values;\n            var isInputFocused = values.isInputFocused, hoverString = values.hoverString, inputString = values.inputString, selectedValue = values.selectedValue;\n            var boundaryValue = isInputFocused ? _this.dateStringToMoment(inputString) : selectedValue;\n            if (hoverString != null) {\n                // don't show an error state while we're hovering over a valid date.\n                return false;\n            }\n            else if (dateUtils_1.isMomentNull(boundaryValue)) {\n                return false;\n            }\n            else if (!boundaryValue.isValid()) {\n                return true;\n            }\n            else if (!_this.isMomentInRange(boundaryValue)) {\n                return true;\n            }\n            else if (_this.doesEndBoundaryOverlapStartBoundary(boundaryValue, boundary)) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        };\n        _this.isMomentValidAndInRange = function (momentDate) {\n            return dateUtils_1.isMomentValidAndInRange(momentDate, _this.props.minDate, _this.props.maxDate);\n        };\n        _this.isMomentInRange = function (momentDate) {\n            return dateUtils_1.isMomentInRange(momentDate, _this.props.minDate, _this.props.maxDate);\n        };\n        _this.reset(props);\n        return _this;\n    }\n    /**\n     * Public method intended for unit testing only. Do not use in feature work!\n     */\n    DateRangeInput.prototype.reset = function (props) {\n        if (props === void 0) { props = this.props; }\n        var _a = this.getInitialRange(), selectedStart = _a[0], selectedEnd = _a[1];\n        this.state = {\n            formattedMaxDateString: this.getFormattedMinMaxDateString(props, \"maxDate\"),\n            formattedMinDateString: this.getFormattedMinMaxDateString(props, \"minDate\"),\n            isOpen: false,\n            selectedEnd: selectedEnd,\n            selectedStart: selectedStart,\n        };\n    };\n    DateRangeInput.prototype.componentDidUpdate = function () {\n        var _a = this.state, isStartInputFocused = _a.isStartInputFocused, isEndInputFocused = _a.isEndInputFocused, shouldSelectAfterUpdate = _a.shouldSelectAfterUpdate;\n        var shouldFocusStartInput = this.shouldFocusInputRef(isStartInputFocused, this.startInputRef);\n        var shouldFocusEndInput = this.shouldFocusInputRef(isEndInputFocused, this.endInputRef);\n        if (shouldFocusStartInput) {\n            this.startInputRef.focus();\n        }\n        else if (shouldFocusEndInput) {\n            this.endInputRef.focus();\n        }\n        if (isStartInputFocused && shouldSelectAfterUpdate) {\n            this.startInputRef.select();\n        }\n        else if (isEndInputFocused && shouldSelectAfterUpdate) {\n            this.endInputRef.select();\n        }\n    };\n    DateRangeInput.prototype.render = function () {\n        var popoverContent = (React.createElement(dateRangePicker_1.DateRangePicker, tslib_1.__assign({}, this.props, { boundaryToModify: this.state.boundaryToModify, onChange: this.handleDateRangePickerChange, onHoverChange: this.handleDateRangePickerHoverChange, value: this.getSelectedRange() })));\n        // allow custom props for the popover and each input group, but pass them in an order that\n        // guarantees only some props are overridable.\n        return (React.createElement(core_1.Popover, tslib_1.__assign({ inline: true, isOpen: this.state.isOpen, position: core_1.Position.BOTTOM_LEFT }, this.props.popoverProps, { autoFocus: false, content: popoverContent, enforceFocus: false, onClose: this.handlePopoverClose }),\n            React.createElement(\"div\", { className: core_1.Classes.CONTROL_GROUP },\n                this.renderInputGroup(dateUtils_1.DateRangeBoundary.START),\n                this.renderInputGroup(dateUtils_1.DateRangeBoundary.END))));\n    };\n    DateRangeInput.prototype.componentWillReceiveProps = function (nextProps) {\n        _super.prototype.componentWillReceiveProps.call(this, nextProps);\n        var nextState = {};\n        if (nextProps.value !== this.props.value) {\n            var _a = this.getInitialRange(nextProps), selectedStart = _a[0], selectedEnd = _a[1];\n            nextState = tslib_1.__assign({}, nextState, { selectedStart: selectedStart, selectedEnd: selectedEnd });\n        }\n        // we use Moment to format date strings, but min/max dates come in as vanilla JS Dates.\n        // cache the formatted date strings to avoid creating new Moment instances on each render.\n        var didFormatChange = nextProps.format !== this.props.format;\n        if (didFormatChange || nextProps.minDate !== this.props.minDate) {\n            var formattedMinDateString = this.getFormattedMinMaxDateString(nextProps, \"minDate\");\n            nextState = tslib_1.__assign({}, nextState, { formattedMinDateString: formattedMinDateString });\n        }\n        if (didFormatChange || nextProps.maxDate !== this.props.maxDate) {\n            var formattedMaxDateString = this.getFormattedMinMaxDateString(nextProps, \"maxDate\");\n            nextState = tslib_1.__assign({}, nextState, { formattedMaxDateString: formattedMaxDateString });\n        }\n        this.setState(nextState);\n    };\n    DateRangeInput.prototype.validateProps = function (props) {\n        if (props.value === null) {\n            throw new Error(Errors.DATERANGEINPUT_NULL_VALUE);\n        }\n    };\n    // Helpers\n    // =======\n    DateRangeInput.prototype.shouldFocusInputRef = function (isFocused, inputRef) {\n        return isFocused && inputRef !== undefined && document.activeElement !== inputRef;\n    };\n    DateRangeInput.prototype.isNextDateRangeValid = function (nextMomentDate, boundary) {\n        return this.isMomentValidAndInRange(nextMomentDate) && !this.doBoundaryDatesOverlap(nextMomentDate, boundary);\n    };\n    // this is a slightly kludgy function, but it saves us a good amount of repeated code between\n    // the constructor and componentWillReceiveProps.\n    DateRangeInput.prototype.getFormattedMinMaxDateString = function (props, propName) {\n        var date = props[propName];\n        var defaultDate = DateRangeInput.defaultProps[propName];\n        // default values are applied only if a prop is strictly `undefined`\n        // See: https://facebook.github.io/react/docs/react-component.html#defaultprops\n        return this.getFormattedDateString(moment(date === undefined ? defaultDate : date), props.format);\n    };\n    return DateRangeInput;\n}(core_1.AbstractComponent));\nDateRangeInput.defaultProps = {\n    allowSingleDayRange: false,\n    closeOnSelection: true,\n    contiguousCalendarMonths: true,\n    dayPickerProps: {},\n    disabled: false,\n    endInputProps: {},\n    format: \"YYYY-MM-DD\",\n    invalidDateMessage: \"Invalid date\",\n    maxDate: datePickerCore_1.getDefaultMaxDate(),\n    minDate: datePickerCore_1.getDefaultMinDate(),\n    outOfRangeMessage: \"Out of range\",\n    overlappingDatesMessage: \"Overlapping dates\",\n    popoverProps: {},\n    selectAllOnFocus: false,\n    shortcuts: true,\n    startInputProps: {},\n};\nDateRangeInput.displayName = \"Blueprint.DateRangeInput\";\nexports.DateRangeInput = DateRangeInput;\n\n//# sourceMappingURL=dateRangeInput.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/dateRangeInput.js\n// module id = 17\n// module chunks = 0","/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar core_1 = require(\"@blueprintjs/core\");\nvar classNames = require(\"classnames\");\nvar React = require(\"react\");\nvar ReactDayPicker = require(\"react-day-picker\");\nvar DateClasses = require(\"./common/classes\");\nvar DateUtils = require(\"./common/dateUtils\");\nvar DateRangeBoundary = DateUtils.DateRangeBoundary;\nvar Errors = require(\"./common/errors\");\nvar monthAndYear_1 = require(\"./common/monthAndYear\");\nvar datePickerCaption_1 = require(\"./datePickerCaption\");\nvar datePickerCore_1 = require(\"./datePickerCore\");\nvar dateRangeSelectionStrategy_1 = require(\"./dateRangeSelectionStrategy\");\nvar DateRangePicker = (function (_super) {\n    tslib_1.__extends(DateRangePicker, _super);\n    function DateRangePicker(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        // these will get merged with the user's own\n        _this.modifiers = (_a = {},\n            _a[datePickerCore_1.SELECTED_RANGE_MODIFIER] = function (day) {\n                var value = _this.state.value;\n                return value[0] != null && value[1] != null && DateUtils.isDayInRange(day, value, true);\n            },\n            _a[datePickerCore_1.SELECTED_RANGE_MODIFIER + \"-start\"] = function (day) { return DateUtils.areSameDay(_this.state.value[0], day); },\n            _a[datePickerCore_1.SELECTED_RANGE_MODIFIER + \"-end\"] = function (day) { return DateUtils.areSameDay(_this.state.value[1], day); },\n            _a[datePickerCore_1.HOVERED_RANGE_MODIFIER] = function (day) {\n                var _a = _this.state, hoverValue = _a.hoverValue, value = _a.value;\n                var selectedStart = value[0], selectedEnd = value[1];\n                if (selectedStart == null && selectedEnd == null) {\n                    return false;\n                }\n                if (hoverValue == null || hoverValue[0] == null || hoverValue[1] == null) {\n                    return false;\n                }\n                return DateUtils.isDayInRange(day, hoverValue, true);\n            },\n            _a[datePickerCore_1.HOVERED_RANGE_MODIFIER + \"-start\"] = function (day) {\n                var hoverValue = _this.state.hoverValue;\n                if (hoverValue == null || hoverValue[0] == null) {\n                    return false;\n                }\n                return DateUtils.areSameDay(hoverValue[0], day);\n            },\n            _a[datePickerCore_1.HOVERED_RANGE_MODIFIER + \"-end\"] = function (day) {\n                var hoverValue = _this.state.hoverValue;\n                if (hoverValue == null || hoverValue[1] == null) {\n                    return false;\n                }\n                return DateUtils.areSameDay(hoverValue[1], day);\n            },\n            _a);\n        _this.disabledDays = function (day) { return !DateUtils.isDayInRange(day, [_this.props.minDate, _this.props.maxDate]); };\n        _this.getDisabledDaysModifier = function () {\n            var disabledDays = _this.props.dayPickerProps.disabledDays;\n            return disabledDays instanceof Array ? [_this.disabledDays].concat(disabledDays) : [_this.disabledDays, disabledDays];\n        };\n        _this.renderSingleCaption = function (captionProps) { return (React.createElement(datePickerCaption_1.DatePickerCaption, tslib_1.__assign({}, captionProps, { maxDate: _this.props.maxDate, minDate: _this.props.minDate, onMonthChange: _this.handleLeftMonthSelectChange, onYearChange: _this.handleLeftYearSelectChange }))); };\n        _this.renderLeftCaption = function (captionProps) { return (React.createElement(datePickerCaption_1.DatePickerCaption, tslib_1.__assign({}, captionProps, { maxDate: DateUtils.getDatePreviousMonth(_this.props.maxDate), minDate: _this.props.minDate, onMonthChange: _this.handleLeftMonthSelectChange, onYearChange: _this.handleLeftYearSelectChange }))); };\n        _this.renderRightCaption = function (captionProps) { return (React.createElement(datePickerCaption_1.DatePickerCaption, tslib_1.__assign({}, captionProps, { maxDate: _this.props.maxDate, minDate: DateUtils.getDateNextMonth(_this.props.minDate), onMonthChange: _this.handleRightMonthSelectChange, onYearChange: _this.handleRightYearSelectChange }))); };\n        _this.handleDayMouseEnter = function (day, modifiers, e) {\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onDayMouseEnter, day, modifiers, e);\n            if (modifiers.disabled) {\n                return;\n            }\n            var _a = dateRangeSelectionStrategy_1.DateRangeSelectionStrategy.getNextState(_this.state.value, day, _this.props.allowSingleDayRange, _this.props.boundaryToModify), dateRange = _a.dateRange, boundary = _a.boundary;\n            _this.setState({ hoverValue: dateRange });\n            core_1.Utils.safeInvoke(_this.props.onHoverChange, dateRange, day, boundary);\n        };\n        _this.handleDayMouseLeave = function (day, modifiers, e) {\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onDayMouseLeave, day, modifiers, e);\n            if (modifiers.disabled) {\n                return;\n            }\n            _this.setState({ hoverValue: undefined });\n            core_1.Utils.safeInvoke(_this.props.onHoverChange, undefined, day, undefined);\n        };\n        _this.handleDayClick = function (day, modifiers, e) {\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onDayClick, day, modifiers, e);\n            if (modifiers.disabled) {\n                // rerender base component to get around bug where you can navigate past bounds by clicking days\n                _this.forceUpdate();\n                return;\n            }\n            var nextValue = dateRangeSelectionStrategy_1.DateRangeSelectionStrategy.getNextState(_this.state.value, day, _this.props.allowSingleDayRange, _this.props.boundaryToModify).dateRange;\n            // update the hovered date range after click to show the newly selected\n            // state, at leasts until the mouse moves again\n            _this.handleDayMouseEnter(day, modifiers, e);\n            _this.handleNextState(nextValue);\n        };\n        _this.handleLeftMonthChange = function (newDate) {\n            var leftView = new monthAndYear_1.MonthAndYear(newDate.getMonth(), newDate.getFullYear());\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, leftView.getFullDate());\n            _this.updateLeftView(leftView);\n        };\n        _this.handleRightMonthChange = function (newDate) {\n            var rightView = new monthAndYear_1.MonthAndYear(newDate.getMonth(), newDate.getFullYear());\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, rightView.getFullDate());\n            _this.updateRightView(rightView);\n        };\n        _this.handleLeftMonthSelectChange = function (leftMonth) {\n            var leftView = new monthAndYear_1.MonthAndYear(leftMonth, _this.state.leftView.getYear());\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, leftView.getFullDate());\n            _this.updateLeftView(leftView);\n        };\n        _this.handleRightMonthSelectChange = function (rightMonth) {\n            var rightView = new monthAndYear_1.MonthAndYear(rightMonth, _this.state.rightView.getYear());\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, rightView.getFullDate());\n            _this.updateRightView(rightView);\n        };\n        /*\n        * The min / max months are offset by one because we are showing two months.\n        * We do a comparison check to see if\n        *   a) the proposed [Month, Year] change throws the two calendars out of order\n        *   b) the proposed [Month, Year] goes beyond the min / max months\n        * and rectify appropriately.\n        */\n        _this.handleLeftYearSelectChange = function (leftDisplayYear) {\n            var leftView = new monthAndYear_1.MonthAndYear(_this.state.leftView.getMonth(), leftDisplayYear);\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, leftView.getFullDate());\n            var _a = _this.props, minDate = _a.minDate, maxDate = _a.maxDate;\n            var adjustedMaxDate = DateUtils.getDatePreviousMonth(maxDate);\n            var minMonthAndYear = new monthAndYear_1.MonthAndYear(minDate.getMonth(), minDate.getFullYear());\n            var maxMonthAndYear = new monthAndYear_1.MonthAndYear(adjustedMaxDate.getMonth(), adjustedMaxDate.getFullYear());\n            if (leftView.isBefore(minMonthAndYear)) {\n                leftView = minMonthAndYear;\n            }\n            else if (leftView.isAfter(maxMonthAndYear)) {\n                leftView = maxMonthAndYear;\n            }\n            var rightView = _this.state.rightView.clone();\n            if (!leftView.isBefore(rightView)) {\n                rightView = leftView.getNextMonth();\n            }\n            _this.setViews(leftView, rightView);\n        };\n        _this.handleRightYearSelectChange = function (rightDisplayYear) {\n            var rightView = new monthAndYear_1.MonthAndYear(_this.state.rightView.getMonth(), rightDisplayYear);\n            core_1.Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, rightView.getFullDate());\n            var _a = _this.props, minDate = _a.minDate, maxDate = _a.maxDate;\n            var adjustedMinDate = DateUtils.getDateNextMonth(minDate);\n            var minMonthAndYear = new monthAndYear_1.MonthAndYear(adjustedMinDate.getMonth(), adjustedMinDate.getFullYear());\n            var maxMonthAndYear = new monthAndYear_1.MonthAndYear(maxDate.getMonth(), maxDate.getFullYear());\n            if (rightView.isBefore(minMonthAndYear)) {\n                rightView = minMonthAndYear;\n            }\n            else if (rightView.isAfter(maxMonthAndYear)) {\n                rightView = maxMonthAndYear;\n            }\n            var leftView = _this.state.leftView.clone();\n            if (!rightView.isAfter(leftView)) {\n                leftView = rightView.getPreviousMonth();\n            }\n            _this.setViews(leftView, rightView);\n        };\n        var value = [null, null];\n        if (props.value != null) {\n            value = props.value;\n        }\n        else if (props.defaultValue != null) {\n            value = props.defaultValue;\n        }\n        var initialMonth;\n        var today = new Date();\n        if (props.initialMonth != null) {\n            initialMonth = props.initialMonth;\n        }\n        else if (value[0] != null) {\n            initialMonth = DateUtils.clone(value[0]);\n        }\n        else if (DateUtils.isDayInRange(today, [props.minDate, props.maxDate])) {\n            initialMonth = today;\n        }\n        else {\n            initialMonth = DateUtils.getDateBetween([props.minDate, props.maxDate]);\n        }\n        /*\n        * if the initial month is the last month of the picker's\n        * allowable range, the react-day-picker library will show\n        * the max month on the left and the *min* month on the right.\n        * subtracting one avoids that weird, wraparound state (#289).\n        */\n        var initialMonthEqualsMinMonth = DateUtils.areSameMonth(initialMonth, props.minDate);\n        var initalMonthEqualsMaxMonth = DateUtils.areSameMonth(initialMonth, props.maxDate);\n        if (!initialMonthEqualsMinMonth && initalMonthEqualsMaxMonth) {\n            initialMonth.setMonth(initialMonth.getMonth() - 1);\n        }\n        var leftView = new monthAndYear_1.MonthAndYear(initialMonth.getMonth(), initialMonth.getFullYear());\n        var rightView = leftView.getNextMonth();\n        _this.state = { leftView: leftView, rightView: rightView, value: value, hoverValue: [null, null] };\n        return _this;\n        var _a;\n    }\n    Object.defineProperty(DateRangePicker.prototype, \"isControlled\", {\n        get: function () {\n            return this.props.value != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DateRangePicker.prototype.render = function () {\n        var modifiers = datePickerCore_1.combineModifiers(this.modifiers, this.props.modifiers);\n        var _a = this.props, className = _a.className, contiguousCalendarMonths = _a.contiguousCalendarMonths, dayPickerProps = _a.dayPickerProps, locale = _a.locale, localeUtils = _a.localeUtils, maxDate = _a.maxDate, minDate = _a.minDate;\n        var isShowingOneMonth = DateUtils.areSameMonth(this.props.minDate, this.props.maxDate);\n        var _b = this.state, leftView = _b.leftView, rightView = _b.rightView;\n        var disabledDays = this.getDisabledDaysModifier();\n        var dayPickerBaseProps = tslib_1.__assign({ enableOutsideDays: true, locale: locale,\n            localeUtils: localeUtils,\n            modifiers: modifiers }, dayPickerProps, { disabledDays: disabledDays, onDayClick: this.handleDayClick, onDayMouseEnter: this.handleDayMouseEnter, onDayMouseLeave: this.handleDayMouseLeave, selectedDays: this.state.value });\n        if (contiguousCalendarMonths || isShowingOneMonth) {\n            var classes = classNames(DateClasses.DATEPICKER, DateClasses.DATERANGEPICKER, className, (_c = {},\n                _c[DateClasses.DATERANGEPICKER_CONTIGUOUS] = contiguousCalendarMonths,\n                _c[DateClasses.DATERANGEPICKER_SINGLE_MONTH] = isShowingOneMonth,\n                _c));\n            // use the left DayPicker when we only need one\n            return (React.createElement(\"div\", { className: classes },\n                this.maybeRenderShortcuts(),\n                React.createElement(ReactDayPicker, tslib_1.__assign({}, dayPickerBaseProps, { captionElement: this.renderSingleCaption, fromMonth: minDate, month: leftView.getFullDate(), numberOfMonths: isShowingOneMonth ? 1 : 2, onMonthChange: this.handleLeftMonthChange, toMonth: maxDate }))));\n        }\n        else {\n            return (React.createElement(\"div\", { className: classNames(DateClasses.DATEPICKER, DateClasses.DATERANGEPICKER, className) },\n                this.maybeRenderShortcuts(),\n                React.createElement(ReactDayPicker, tslib_1.__assign({}, dayPickerBaseProps, { canChangeMonth: true, captionElement: this.renderLeftCaption, fromMonth: minDate, month: leftView.getFullDate(), onMonthChange: this.handleLeftMonthChange, toMonth: DateUtils.getDatePreviousMonth(maxDate) })),\n                React.createElement(ReactDayPicker, tslib_1.__assign({}, dayPickerBaseProps, { canChangeMonth: true, captionElement: this.renderRightCaption, fromMonth: DateUtils.getDateNextMonth(minDate), month: rightView.getFullDate(), onMonthChange: this.handleRightMonthChange, toMonth: maxDate }))));\n        }\n        var _c;\n    };\n    DateRangePicker.prototype.componentWillReceiveProps = function (nextProps) {\n        _super.prototype.componentWillReceiveProps.call(this, nextProps);\n        if (!DateUtils.areRangesEqual(this.props.value, nextProps.value)) {\n            var nextState = getStateChange(this.props.value, nextProps.value, this.state, nextProps.contiguousCalendarMonths);\n            this.setState(nextState);\n        }\n    };\n    DateRangePicker.prototype.validateProps = function (props) {\n        var defaultValue = props.defaultValue, initialMonth = props.initialMonth, maxDate = props.maxDate, minDate = props.minDate, boundaryToModify = props.boundaryToModify, value = props.value;\n        var dateRange = [minDate, maxDate];\n        if (defaultValue != null && !DateUtils.isDayRangeInRange(defaultValue, dateRange)) {\n            throw new Error(Errors.DATERANGEPICKER_DEFAULT_VALUE_INVALID);\n        }\n        if (initialMonth != null && !DateUtils.isMonthInRange(initialMonth, dateRange)) {\n            throw new Error(Errors.DATERANGEPICKER_INITIAL_MONTH_INVALID);\n        }\n        if (maxDate != null && minDate != null && maxDate < minDate && !DateUtils.areSameDay(maxDate, minDate)) {\n            throw new Error(Errors.DATERANGEPICKER_MAX_DATE_INVALID);\n        }\n        if (value != null && !DateUtils.isDayRangeInRange(value, dateRange)) {\n            throw new Error(Errors.DATERANGEPICKER_VALUE_INVALID);\n        }\n        if (boundaryToModify != null &&\n            boundaryToModify !== DateRangeBoundary.START &&\n            boundaryToModify !== DateRangeBoundary.END) {\n            throw new Error(Errors.DATERANGEPICKER_PREFERRED_BOUNDARY_TO_MODIFY_INVALID);\n        }\n    };\n    DateRangePicker.prototype.maybeRenderShortcuts = function () {\n        var _this = this;\n        var propsShortcuts = this.props.shortcuts;\n        if (propsShortcuts == null || propsShortcuts === false) {\n            return undefined;\n        }\n        var shortcuts = typeof propsShortcuts === \"boolean\" ? createDefaultShortcuts() : propsShortcuts;\n        var shortcutElements = shortcuts.map(function (s, i) {\n            return (React.createElement(core_1.MenuItem, { className: core_1.Classes.POPOVER_DISMISS_OVERRIDE, disabled: !_this.isShortcutInRange(s.dateRange), key: i, onClick: _this.getShorcutClickHandler(s.dateRange), text: s.label }));\n        });\n        return React.createElement(core_1.Menu, { className: DateClasses.DATERANGEPICKER_SHORTCUTS }, shortcutElements);\n    };\n    DateRangePicker.prototype.getShorcutClickHandler = function (nextValue) {\n        var _this = this;\n        return function () { return _this.handleNextState(nextValue); };\n    };\n    DateRangePicker.prototype.handleNextState = function (nextValue) {\n        var value = this.state.value;\n        var nextState = getStateChange(value, nextValue, this.state, this.props.contiguousCalendarMonths);\n        if (!this.isControlled) {\n            this.setState(nextState);\n        }\n        core_1.Utils.safeInvoke(this.props.onChange, nextValue);\n    };\n    DateRangePicker.prototype.updateLeftView = function (leftView) {\n        var rightView = this.state.rightView.clone();\n        if (!leftView.isBefore(rightView)) {\n            rightView = leftView.getNextMonth();\n        }\n        this.setViews(leftView, rightView);\n    };\n    DateRangePicker.prototype.updateRightView = function (rightView) {\n        var leftView = this.state.leftView.clone();\n        if (!rightView.isAfter(leftView)) {\n            leftView = rightView.getPreviousMonth();\n        }\n        this.setViews(leftView, rightView);\n    };\n    DateRangePicker.prototype.setViews = function (leftView, rightView) {\n        this.setState({ leftView: leftView, rightView: rightView });\n    };\n    DateRangePicker.prototype.isShortcutInRange = function (shortcutDateRange) {\n        return DateUtils.isDayRangeInRange(shortcutDateRange, [this.props.minDate, this.props.maxDate]);\n    };\n    return DateRangePicker;\n}(core_1.AbstractComponent));\nDateRangePicker.defaultProps = {\n    allowSingleDayRange: false,\n    contiguousCalendarMonths: true,\n    dayPickerProps: {},\n    maxDate: datePickerCore_1.getDefaultMaxDate(),\n    minDate: datePickerCore_1.getDefaultMinDate(),\n    shortcuts: true,\n};\nDateRangePicker.displayName = \"Blueprint.DateRangePicker\";\nexports.DateRangePicker = DateRangePicker;\nfunction getStateChange(value, nextValue, state, contiguousCalendarMonths) {\n    var returnVal;\n    if (value != null && nextValue == null) {\n        returnVal = { value: [null, null] };\n    }\n    else if (nextValue != null) {\n        var nextValueStart = nextValue[0], nextValueEnd = nextValue[1];\n        var leftView = state.leftView.clone();\n        var rightView = state.rightView.clone();\n        /*\n        * Only end date selected.\n        * If the newly selected end date isn't in either of the displayed months, then\n        *   - set the right DayPicker to the month of the selected end date\n        *   - ensure the left DayPicker is before the right, changing if needed\n        */\n        if (nextValueStart == null && nextValueEnd != null) {\n            var nextValueEndMonthAndYear = new monthAndYear_1.MonthAndYear(nextValueEnd.getMonth(), nextValueEnd.getFullYear());\n            if (!nextValueEndMonthAndYear.isSame(leftView) && !nextValueEndMonthAndYear.isSame(rightView)) {\n                rightView = nextValueEndMonthAndYear;\n                if (!leftView.isBefore(rightView)) {\n                    leftView = rightView.getPreviousMonth();\n                }\n            }\n            /*\n        * Only start date selected.\n        * If the newly selected start date isn't in either of the displayed months, then\n        *   - set the left DayPicker to the month of the selected start date\n        *   - ensure the right DayPicker is before the left, changing if needed\n        */\n        }\n        else if (nextValueStart != null && nextValueEnd == null) {\n            var nextValueStartMonthAndYear = new monthAndYear_1.MonthAndYear(nextValueStart.getMonth(), nextValueStart.getFullYear());\n            if (!nextValueStartMonthAndYear.isSame(leftView) && !nextValueStartMonthAndYear.isSame(rightView)) {\n                leftView = nextValueStartMonthAndYear;\n                if (!rightView.isAfter(leftView)) {\n                    rightView = leftView.getNextMonth();\n                }\n            }\n            /*\n        * Both start date and end date selected.\n        */\n        }\n        else if (nextValueStart != null && nextValueEnd != null) {\n            var nextValueStartMonthAndYear = new monthAndYear_1.MonthAndYear(nextValueStart.getMonth(), nextValueStart.getFullYear());\n            var nextValueEndMonthAndYear = new monthAndYear_1.MonthAndYear(nextValueEnd.getMonth(), nextValueEnd.getFullYear());\n            /*\n            * Both start and end date months are identical\n            * If the selected month isn't in either of the displayed months, then\n            *   - set the left DayPicker to be the selected month\n            *   - set the right DayPicker to +1\n            */\n            if (DateUtils.areSameMonth(nextValueStart, nextValueEnd)) {\n                var potentialLeftEqualsNextValueStart = leftView.isSame(nextValueStartMonthAndYear);\n                var potentialRightEqualsNextValueStart = rightView.isSame(nextValueStartMonthAndYear);\n                if (potentialLeftEqualsNextValueStart || potentialRightEqualsNextValueStart) {\n                    // do nothing\n                }\n                else {\n                    leftView = nextValueStartMonthAndYear;\n                    rightView = nextValueStartMonthAndYear.getNextMonth();\n                }\n                /*\n            * Different start and end date months, adjust display months.\n            */\n            }\n            else {\n                if (!leftView.isSame(nextValueStartMonthAndYear)) {\n                    leftView = nextValueStartMonthAndYear;\n                    rightView = nextValueStartMonthAndYear.getNextMonth();\n                }\n                if (contiguousCalendarMonths === false && !rightView.isSame(nextValueEndMonthAndYear)) {\n                    rightView = nextValueEndMonthAndYear;\n                }\n            }\n        }\n        returnVal = {\n            leftView: leftView,\n            rightView: rightView,\n            value: nextValue,\n        };\n    }\n    else {\n        returnVal = {};\n    }\n    return returnVal;\n}\nfunction createShortcut(label, dateRange) {\n    return { dateRange: dateRange, label: label };\n}\nfunction createDefaultShortcuts() {\n    var today = new Date();\n    var makeDate = function (action) {\n        var returnVal = DateUtils.clone(today);\n        action(returnVal);\n        returnVal.setDate(returnVal.getDate() + 1);\n        return returnVal;\n    };\n    var oneWeekAgo = makeDate(function (d) { return d.setDate(d.getDate() - 7); });\n    var oneMonthAgo = makeDate(function (d) { return d.setMonth(d.getMonth() - 1); });\n    var threeMonthsAgo = makeDate(function (d) { return d.setMonth(d.getMonth() - 3); });\n    var sixMonthsAgo = makeDate(function (d) { return d.setMonth(d.getMonth() - 6); });\n    var oneYearAgo = makeDate(function (d) { return d.setFullYear(d.getFullYear() - 1); });\n    var twoYearsAgo = makeDate(function (d) { return d.setFullYear(d.getFullYear() - 2); });\n    return [\n        createShortcut(\"Past week\", [oneWeekAgo, today]),\n        createShortcut(\"Past month\", [oneMonthAgo, today]),\n        createShortcut(\"Past 3 months\", [threeMonthsAgo, today]),\n        createShortcut(\"Past 6 months\", [sixMonthsAgo, today]),\n        createShortcut(\"Past year\", [oneYearAgo, today]),\n        createShortcut(\"Past 2 years\", [twoYearsAgo, today]),\n    ];\n}\nexports.DateRangePickerFactory = React.createFactory(DateRangePicker);\n\n//# sourceMappingURL=dateRangePicker.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/dateRangePicker.js\n// module id = 18\n// module chunks = 0","/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dateUtils_1 = require(\"./dateUtils\");\nvar MonthAndYear = (function () {\n    function MonthAndYear(month, year) {\n        if (month !== null && year !== null) {\n            this.date = new Date(year, month);\n        }\n        else {\n            this.date = new Date();\n        }\n    }\n    MonthAndYear.prototype.clone = function () {\n        return new MonthAndYear(this.getMonth(), this.getYear());\n    };\n    MonthAndYear.prototype.getFullDate = function () {\n        return this.date;\n    };\n    MonthAndYear.prototype.getMonth = function () {\n        return this.date.getMonth();\n    };\n    MonthAndYear.prototype.getYear = function () {\n        return this.date.getFullYear();\n    };\n    MonthAndYear.prototype.getPreviousMonth = function () {\n        var previousMonthDate = dateUtils_1.getDatePreviousMonth(this.date);\n        return new MonthAndYear(previousMonthDate.getMonth(), previousMonthDate.getFullYear());\n    };\n    MonthAndYear.prototype.getNextMonth = function () {\n        var nextMonthDate = dateUtils_1.getDateNextMonth(this.date);\n        return new MonthAndYear(nextMonthDate.getMonth(), nextMonthDate.getFullYear());\n    };\n    MonthAndYear.prototype.isBefore = function (monthAndYear) {\n        return compareMonthAndYear(this, monthAndYear) < 0;\n    };\n    MonthAndYear.prototype.isAfter = function (monthAndYear) {\n        return compareMonthAndYear(this, monthAndYear) > 0;\n    };\n    MonthAndYear.prototype.isSame = function (monthAndYear) {\n        return compareMonthAndYear(this, monthAndYear) === 0;\n    };\n    return MonthAndYear;\n}());\nexports.MonthAndYear = MonthAndYear;\n// returns negative if left < right\n// returns positive if left > right\n// returns 0 if left === right\nfunction compareMonthAndYear(firstMonthAndYear, secondMonthAndYear) {\n    var firstMonth = firstMonthAndYear.getMonth();\n    var firstYear = firstMonthAndYear.getYear();\n    var secondMonth = secondMonthAndYear.getMonth();\n    var secondYear = secondMonthAndYear.getYear();\n    if (firstYear === secondYear) {\n        return firstMonth - secondMonth;\n    }\n    else {\n        return firstYear - secondYear;\n    }\n}\n\n//# sourceMappingURL=monthAndYear.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/common/monthAndYear.js\n// module id = 19\n// module chunks = 0","/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dateUtils_1 = require(\"./common/dateUtils\");\nvar DateRangeSelectionStrategy = (function () {\n    function DateRangeSelectionStrategy() {\n    }\n    /**\n     * Returns the new date-range and the boundary that would be affected if `day` were clicked. The\n     * affected boundary may be different from the provided `boundary` in some cases. For example,\n     * clicking a particular boundary's selected date will always deselect it regardless of which\n     * `boundary` you provide to this function (because it's simply a more intuitive interaction).\n     */\n    DateRangeSelectionStrategy.getNextState = function (currentRange, day, allowSingleDayRange, boundary) {\n        if (boundary != null) {\n            return this.getNextStateForBoundary(currentRange, day, allowSingleDayRange, boundary);\n        }\n        else {\n            return this.getDefaultNextState(currentRange, day, allowSingleDayRange);\n        }\n    };\n    DateRangeSelectionStrategy.getNextStateForBoundary = function (currentRange, day, allowSingleDayRange, boundary) {\n        var boundaryDate = this.getBoundaryDate(boundary, currentRange);\n        var otherBoundary = this.getOtherBoundary(boundary);\n        var otherBoundaryDate = this.getBoundaryDate(otherBoundary, currentRange);\n        var nextBoundary;\n        var nextDateRange;\n        if (boundaryDate == null && otherBoundaryDate == null) {\n            nextBoundary = boundary;\n            nextDateRange = this.createRangeForBoundary(boundary, day, null);\n        }\n        else if (boundaryDate != null && otherBoundaryDate == null) {\n            var nextBoundaryDate = dateUtils_1.areSameDay(boundaryDate, day) ? null : day;\n            nextBoundary = boundary;\n            nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, null);\n        }\n        else if (boundaryDate == null && otherBoundaryDate != null) {\n            if (dateUtils_1.areSameDay(day, otherBoundaryDate)) {\n                var nextDate = void 0;\n                if (allowSingleDayRange) {\n                    nextBoundary = boundary;\n                    nextDate = otherBoundaryDate;\n                }\n                else {\n                    nextBoundary = otherBoundary;\n                    nextDate = null;\n                }\n                nextDateRange = this.createRangeForBoundary(boundary, nextDate, nextDate);\n            }\n            else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n                nextBoundary = otherBoundary;\n                nextDateRange = this.createRangeForBoundary(boundary, otherBoundaryDate, day);\n            }\n            else {\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n            }\n        }\n        else {\n            // both boundaryDate and otherBoundaryDate are already defined\n            if (dateUtils_1.areSameDay(boundaryDate, day)) {\n                var isSingleDayRangeSelected = dateUtils_1.areSameDay(boundaryDate, otherBoundaryDate);\n                var nextOtherBoundaryDate = isSingleDayRangeSelected ? null : otherBoundaryDate;\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, null, nextOtherBoundaryDate);\n            }\n            else if (dateUtils_1.areSameDay(day, otherBoundaryDate)) {\n                var _a = allowSingleDayRange\n                    ? [otherBoundaryDate, otherBoundaryDate]\n                    : [boundaryDate, null], nextBoundaryDate = _a[0], nextOtherBoundaryDate = _a[1];\n                nextBoundary = allowSingleDayRange ? boundary : otherBoundary;\n                nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, nextOtherBoundaryDate);\n            }\n            else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, null);\n            }\n            else {\n                // extend the date range with an earlier boundaryDate date\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n            }\n        }\n        return { dateRange: nextDateRange, boundary: nextBoundary };\n    };\n    DateRangeSelectionStrategy.getDefaultNextState = function (selectedRange, day, allowSingleDayRange) {\n        var start = selectedRange[0], end = selectedRange[1];\n        var nextDateRange;\n        if (start == null && end == null) {\n            nextDateRange = [day, null];\n        }\n        else if (start != null && end == null) {\n            nextDateRange = this.createRange(day, start, allowSingleDayRange);\n        }\n        else if (start == null && end != null) {\n            nextDateRange = this.createRange(day, end, allowSingleDayRange);\n        }\n        else {\n            var isStart = dateUtils_1.areSameDay(start, day);\n            var isEnd = dateUtils_1.areSameDay(end, day);\n            if (isStart && isEnd) {\n                nextDateRange = [null, null];\n            }\n            else if (isStart) {\n                nextDateRange = [null, end];\n            }\n            else if (isEnd) {\n                nextDateRange = [start, null];\n            }\n            else {\n                nextDateRange = [day, null];\n            }\n        }\n        return { dateRange: nextDateRange };\n    };\n    DateRangeSelectionStrategy.getOtherBoundary = function (boundary) {\n        return boundary === dateUtils_1.DateRangeBoundary.START ? dateUtils_1.DateRangeBoundary.END : dateUtils_1.DateRangeBoundary.START;\n    };\n    DateRangeSelectionStrategy.getBoundaryDate = function (boundary, dateRange) {\n        return boundary === dateUtils_1.DateRangeBoundary.START ? dateRange[0] : dateRange[1];\n    };\n    DateRangeSelectionStrategy.isOverlappingOtherBoundary = function (boundary, boundaryDate, otherBoundaryDate) {\n        return boundary === dateUtils_1.DateRangeBoundary.START\n            ? boundaryDate > otherBoundaryDate\n            : boundaryDate < otherBoundaryDate;\n    };\n    DateRangeSelectionStrategy.createRangeForBoundary = function (boundary, boundaryDate, otherBoundaryDate) {\n        return boundary === dateUtils_1.DateRangeBoundary.START\n            ? [boundaryDate, otherBoundaryDate]\n            : [otherBoundaryDate, boundaryDate];\n    };\n    DateRangeSelectionStrategy.createRange = function (a, b, allowSingleDayRange) {\n        // clicking the same date again will clear it\n        if (!allowSingleDayRange && dateUtils_1.areSameDay(a, b)) {\n            return [null, null];\n        }\n        return a < b ? [a, b] : [b, a];\n    };\n    return DateRangeSelectionStrategy;\n}());\nexports.DateRangeSelectionStrategy = DateRangeSelectionStrategy;\n\n//# sourceMappingURL=dateRangeSelectionStrategy.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/datetime/dist/dateRangeSelectionStrategy.js\n// module id = 20\n// module chunks = 0"],"sourceRoot":""}